if $SAFE > 0
  echo "This script needs to be trusted to work properly. (;trust #{script.name})"
  exit
end

require "Olib"

module Functor
  def fmap(method = nil, *args, &block)
    return self.class.of @val.fmap(method, *args, &block) if @val.is_a?(Monad)
    return self.class.of @val.send(method, *args)         if method.is_a?(Symbol)
    self.class.of block.call @val
  end
end

class Monad
  include Functor
  def self.of(val = nil) new val end

  attr_reader :val

  def initialize(val) @val = val end
  def to_s() %{<#{self.class.name}:#{@val || "nil"}>} end
end

class Just < Monad
end

class NothingClass < Monad
  def fmap(*args, &block) self end
  def to_s() "<Nothing>" end
end

Nothing = NothingClass.of

class Maybe < Monad
  def initialize(val)
    if val.nil?
      super(Nothing)
    else
      super(val)
    end
  end

  def fmap(*args)
    if nothing? or args.first.is_a?(Symbol) and not @val.respond_to?(args.first)
      self
    else
      super(*args)
    end
  end

  def nothing?
    @val.eql?(Nothing)
  end

  def something?
    !nothing?
  end
end

module Immutable
  COPY = Proc.new do |item|
    if item.is_a?(Fixnum)
      item
    else
      item.dup
    end
  end

  def self.freeze(obj)
    obj.freeze
  end

  def self.copy(thing = nil)
    return COPY if thing.nil?
    COPY.call(thing)
  end
end

class Tuple
  class InvalidTuple < Exception
    def initialize(keys)
      super %{#{keys} are all required}
    end
  end

  class TupleInstance < Object
    include Enumerable
    include Comparable

    def self.define_key(name, idx)
      define_method name do
        Immutable.copy @vals[idx]
      end
    end

    attr_reader :vals

    def initialize(*vals)
      raise InvalidTuple.new(keys) unless vals.size == keys.size
      @vals = vals.map(&:freeze)
      freeze
    end

    def keys
      self.class.keys
    end

    def [](by)
      if by.is_a?(Fixnum)
        @vals[by]
      elsif keys.include by.to_sym
        send by.to_sym
      else
        raise Exception.new %{
          invalid key #{by}
          must be one of #{keys.join(", ")}
        }
      end
    end

    def each(&block)
      @vals.map(&Immutable.copy).each(&block)
    end

    def to_s
      %{<#{self.class.name} #{@vals.join(", ")}>}
    end
  end

  def self.of(*keys)
    if keys.empty?
      raise Exception.new %{
        invalid Tuple definition

        Tuple must have keys : class Car < Tuple.new(:make, :model)
      }
    end

    Class.new(TupleInstance) do
      @@keys = keys.map(&:to_sym).freeze
      def self.keys() @@keys.dup end
      
      @@keys.each.with_index do |key, idx|
        define_key key, idx
      end
    end
  end
end
##
## contextual logging
##
module Log
  def self.bold(msg)
    _respond "<pushBold/>#{msg}<popBold/>"
  end
  
  def self.out(msg, label = :debug)
    #return unless Opts.debug

    if msg.is_a?(Exception)
      msg = %{
        #{msg.message}
        #{msg.backtrace.join("\n")}
      }
    end

    bold _view(msg, label)
  end

  def self._view(msg, label)
    %{[#{Script.current.name}.#{label}] #{msg}}
  end

  def self.pp(msg, label = :debug)
    respond _view(msg, label)
  end

  def self.dump(*args)
    pp *args
  end
end
##
## XML utils
##
module XML
  def self.xml_on
    Script.current.want_downstream_xml = true
  end

  def self.xml_off
    Script.current.want_downstream_xml = false
  end

  def self.tap
    xml_on
    result = yield
    xml_off
    result
  end

  def self.match(cmd, patt, timeout: 5)
    XML.tap do
      dothistimeout(cmd, timeout, patt)
    end
  end
end
##
## minimal options parser
##
module Opts
  FLAG_PREFIX    = "--"
  
  def self.parse_command(h, c)
    h[c.to_sym] = true
  end

  def self.parse_flag(h, f)
    (name, val) = f[2..-1].split("=")
    if val.nil?
      h[name.to_sym] = true
    else
      val = val.split(",")

      h[name.to_sym] = val.size == 1 ? val.first : val
    end
  end

  def self.parse(args = Script.current.vars[1..-1])    
    config = OpenStruct.new  
    Try.new do  
      if args.size > 0
        config = OpenStruct.new(**args.reduce(Hash.new) do |h, v|
          if v.start_with?(FLAG_PREFIX)
            parse_flag(h, v)
          else
            parse_command(h, v)
          end
          h
        end)
      end
    end
    config
  end

  def self.method_missing(method, *args)
    parse.send(method, *args)
  end
end

class Outcomes
  VAR = %r{\{\{(?<var>.*?)\}\}}
  attr_reader :branches
  def initialize(**branches)
    @branches = branches
  end

  def method_missing(branch)
    return @branches.fetch(branch) if @branches.has_key?(branch)
    super branch
  end

  def compile(object)
    Hash[@branches.map do |k, pattern|
      [k,
        %r{#{pattern.gsub(VAR) do |name|
          name = name.match(VAR).to_struct.var.to_sym
          if object.respond_to?(name)  
            object.send(name) 
          elsif object.respond_to?(:fetch) 
            object.fetch(name)
          elsif object.respond_to?(:[])
            object[name]
          else
            raise Exception.new "could not serialize var: #{name} of #{object.class.name} in Outcome"
          end
        end}}]
    end]
  end

  def with(str, object)
    match(str, 
      compile(object))
  end

  def match(str, outcomes = @branches)
    return [] if str.nil?
    box     = Maybe.of(str)
    matches = []
    outcomes.keys.each do |branch|
      result = box.fmap(:match, outcomes.fetch(branch)).fmap(&:to_struct)
      matches << [branch, result.val] if result.something?
    end
    matches
  end

  def to_s
    inspect
  end

  def only(str)
    match(str).first
  end

  def try(command, outcomes = @branches, timeout: 5)
    match(dothistimeout(command, timeout, 
      Regexp.union(outcomes.values)), outcomes)
  end

  def try_with(command, object, timeout: 5)
    try(command, compile(object), 
      timeout: timeout)
  end

  def try_with_xml(*args, **opts)
    XML.tap do
      try_with(*args, **opts)
    end
  end

  def try_specific(*args, **opts)
    try_with_xml(*args, **opts).first
  end
end

module Skins
  class Bundle
    MEASURE = Outcomes.new(
      ok: %{You glance through your bundle and count a total of (?<count>\\d+) <a exist="{{id}}" noun="{{noun}}">(.*?)</a>.}
    )

    SELL = Outcomes.new(
      ok: %{takes the <a exist="{{id}}" noun="{{noun}}">(.*?)</a>, gives it a careful glance, then pays you (?<price>\\d+) silvers.$}
    )

    REMOVE = Outcomes.new(
      ok: %{^You remove a <a exist="(?<id>\\d+)" noun="(?:[a-z]+)">(.*?)</a> from your bundle of <a exist="{{id}}" noun="{{noun}}">(.*?)</a>.$}
    )

    INFLECT = {
      teeth: "tooth"
    }

    def self.singular(skin)
      parts = skin.split(" ")
      noun  = parts.pop
      (parts + [INFLECT[noun.to_sym] || noun.gsub(/s$/, "")]).join(" ")
    end

    def self.measure(obj)
      MEASURE.try_specific("measure ##{obj.id}", obj)
    end

    def self.list
      Containers.lootsack.skins
        .select do |skin| skin.props.fetch(:desc).include?("bundle") end
        .map do |skin| new(skin) end
    end

    def self.for_bounty
      return [] unless Bounty.type == :skin
      list.select(&:bounty?)
    end

    attr_reader :data
    
    def initialize(obj)
      @ref  = obj
      outcome, data = Bundle.measure(obj)
      if outcome == :ok
        @data = data
      else
        raise Exception.new "[#{type.class.name}.#{type}.#{type == :ok}] could not measure #{obj.name}"
      end
    end
    
    def desc
      @ref.props.fetch(:desc)
    end

    def singular
      Bundle.singular desc
    end

    def stemmed
      singular.split(" ").last(2).join(" ")
    end

    def bounty?
      Bundle.singular(Bounty.skin).include?(stemmed)
    end

    def holding?
      [Char.right, Char.left].compact.map(&:id).include?(@ref.id)
    end

    def remove
      unless holding?
        empty_hands
        @ref.take 
      end
      outcome, data = REMOVE.try_specific("bundle remove", @ref)
      raise Exception.new "unhandled outcome" unless outcome == :ok
      Olib::Item.new GameObj[data.id.to_s]
    end

    def sell(n = @data.count)
      return @ref.sell if n >= @data.count  
      @ref.take
      n.times do
        skin = remove
        SELL.try_specific("sell ##{skin.id}", 
          skin)
      end
      Containers.lootsack.add(self) if holding?
    end

    def method_missing(method, *args)
      if @ref.respond_to?(method)
        @ref.send(method, *args)
      elsif @data.respond_to?(method) and args.empty?
        @data[method]
      else
        super(method, *args)
      end
    end
  end
end