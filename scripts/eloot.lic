# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.
  Requires eloot.ui to be placed in your data folder

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributers: SpiffyJr, Athias, Demandred, Tysong
              game: Gemstone
              tags: loot
           version: 1.0.0
  Improvements:

  v1.0.0 (2022-02-28)
    - forked and renamed as eloot, rebasing version as v1.0.0
    - global rename from SLoot to ELoot
    - corrected ;eloot list to allow for parameters (loot, sell, skin, internal)
    - corrected for box and overflow constraint
    - added 'load' command back in - we found a point!
    - converted all CharSettings to yaml file to improve reliability
    - removed write-to-db3 capability - it is too inconsistent
    - improved bulk-gems logic (with thanks to Izzy101yzzI)
    - support for super secure gem pouches
    - default to silence output

  v2.2.1 (2021-12-23)
    - added any container specified in STOW LIST
    - added 'overflow' capabilities (although I still don't know why)
    - cleaned up bulk gem sales / individual gem sales logic
    - created a write-to-db3 capability rather than relying on lazy writes to db3
    - removed 'load' command - it is pointless

  v2.0.2 (2021-07-25)
    - Our chief edit is the loot. The loot and hands.
    - Our TWO chief edits are loot and hands. And gold rings.
    - Our THREE chief edits are loot, hands and gold rings. And many fixes to stuff and other stuff.
    - AMONG our edits are such diverse changes as loot fixes, items stowing and getting back out, hands, gold rings to chronomage, 604 support...oh nevermind I'll come back in.
    - Seriously though, lots of changes and fixes.
    - Zealot stance stuff removed?
    - Blunt skinning issues
    - More.

  v2.0.1 (2021-05-08)
    - Corrected skinning issue for left-handed skinners

  v2.0.0 (2021-04-12)
    - Rebaselined as SLoot 2.0
    - Fixed locksmith pool being full issue
    - Fixed container full issue when using disks (thanks to Demandred)
    - Added town locksmith processing
    - Added return to original location after ;sloot sell
    - Added expanded detail comment section and version
    - Added title bar update with version
    - Removed Hoarding option and related code
    - Updated internal comments
    - Updated to work with jinx data for sloot.ui

=end

# Check version of Lich for compatibility
LICH_GEM_REQUIRES = '5.4.1'
INFOMON_GEM_REQUIRES = '1.18.11'
INFOMON_VERSION = '0.0.0'
infomon_data = open("#{SCRIPT_DIR}/infomon.lic", 'r').read
if infomon_data =~ /^=begin\r?\n?(.+?)^=end/m
    comments = $1.split("\n")
else
    comments = []
    infomon_data.split("\n").each {|line|
        if line =~ /^[\t\s]*#/
            comments.push(line)
        elsif line !~ /^[\t\s]*$/
            break
        end
    }
end
for line in comments
    if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
        INFOMON_VERSION = $1.sub(/\s\(.*?\)/, '').strip
    end
end

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(LICH_GEM_REQUIRES) || Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(INFOMON_GEM_REQUIRES)
   if $frontend == 'stormfront' || $frontend == 'profanity'
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) & Infomon (#{INFOMON_GEM_REQUIRES}) to run." + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
     _respond ""
     _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Currently Running Infomon Version: #{Gem::Version.new(INFOMON_VERSION) }" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
   else
     _respond "##" + "########################################"
     _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) & Infomon (#{INFOMON_GEM_REQUIRES}) to run."
     _respond ">" + "Please update to a newer version."
     _respond ">" + ""
     _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }"
     _respond ">" + "Currently Running Infomon Version: #{Gem::Version.new(INFOMON_VERSION) }"
     _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
     _respond "##" + "########################################"
   end
   exit
end

ELoot_version = '1.0.0'

require 'yaml' #we clearly need to be saving information without CharSettings

# eloot is a looter for Gemstone that focuses on performance
module ELoot
  @@data ||= nil
  @sacks_to_close = []

  def self.load_defaults()
    dir = "#{$data_dir}eloot"
    filename = "#{dir}/default.yaml"
    if File.exist?("#{filename}")
      default_hash = YAML.load_file("#{filename}")
    else
      default_hash = {
        :loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
        :loot_exclude=>["black ora", "urglaes"],
        :loot_phase=>false,
        :loot_defensive=>false,
        :overflow_container=>"",
        :sell_loot_types=>["alchemy", "armor", "clothing", "collectible", "gem", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
        :sell_exclude=>[],
        :sell_keep_scrolls=>[],
        :sell_appraise_types=>["jewelry", "magic", "uncommon", "valuable"],
        :sell_appraise_gemshop=>14999,
        :sell_appraise_pawnshop=>34999,
        :sell_collectibles=>true,
        :sell_gold_rings=>false,
        :sell_locksmith=>false,
        :sell_locksmith_pool=>true,
        :sell_locksmith_pool_tip=>15,
        :sell_locksmith_pool_tip_percent=>true,
        :sell_share_silvers=>false,
        :sell_fwi=>false,
        :sell_keep_silver=>0,
        :skin_enable=>false,
        :skin_kneel=>false,
        :skin_604=>false,
        :skin_resolve=>false,
        :skin_sheath=>"",
        :skin_weapon=>"",
        :skin_weapon_blunt=>"",
        :silence=>true,
        :debug=>false,
        :unskinnable=>[]
      }
      Dir.mkdir("#{$data_dir}eloot") unless File.exist?("#{$data_dir}eloot")
      File.write(filename, default_hash.to_yaml)
    end
    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      dir = "#{$data_dir}eloot"
      filename = "#{dir}/#{name}.yaml"
      if File.exist?("#{filename}") && name == Char.name
        settings_hash = YAML.load_file(filename)
      elsif !File.exist?("#{filename}") && name != Char.name
        ELoot.msg("error", "ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?("#{filename}") && name == Char.name
        ELoot.msg("info", "No current settings found.  Loading defaults for configurtion.")
        ELoot.msg("info", "Suggest you configure to your needs with ;eloot setup")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg("error", "ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg("error", "ELoot.load_profile: name not defined")
    end
    settings_hash
  end

  def self.save_profile(name: Char.name)
    if name != nil
      Dir.mkdir("#{$data_dir}eloot") unless File.exist?("#{$data_dir}eloot")
      dir = "#{$data_dir}eloot"
      filename = "#{dir}/#{name}.yaml"
      ELoot.data.settings[:debug] = false # never save true
      if name == Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", "Settings saved to file: #{filename}.")
      elsif File.exist?("#{filename}") && name != Char.name
        ELoot.msg("info", "You are attempt to overwrite another profile!")
        ELoot.msg("info", "If you wish to overwrite, please ;unpause eloot.")
        ELoot.msg("info", "Else ;kill eloot and choose another filename.")
        pause_script
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", "Settings saved to file: #{filename}.")
      elsif !File.exist?("#{filename}") && name != Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", "Settings are being saved to another profile!")
        ELoot.msg("info", "Settings saved to file: #{filename}.")
      else
        ELoot.msg("error", "ELoot.save_profile: There was an unknown error with saving a profile")
      end
    end
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.data
    @@data
  end

  def self.sell
    Sell.sell
  end

  def self.msg(type = info, text)
    if type == "debug"
      if ELoot.data.settings[:debug]
        if $frontend == 'stormfront' || $frontend == 'profanity'
          _respond "\<preset id=\"speech\"\>#{text}\<\/preset\>"
        else
          echo ">> #{text}"
        end
      end
    elsif $frontend == 'stormfront' || $frontend == 'profanity'
      if type == "error" || type == "yellow" || type == "bold" || type == "monster" || type == "creature"
        _respond "\<pushBold\/\>#{text}\<popBold\/\>"
      elsif type == "warn" || type == "orange" || type == "thought"
        _respond "\<preset id=\"thought\"\>#{text}\<\/preset\>"
      elsif type == "info" || type == "teal" || type == "whisper"
        _respond "\<preset id=\"whisper\"\>#{text}\<\/preset\>"
      elsif type == "green" || type == "speech"
        _respond "\<preset id=\"speech\"\>#{text}\<\/preset\>"
      else
        puts text
      end
    else
      if type == "error" || type == "yellow" || type == "bold" || type == "monster" || type == "creature"
        echo "** #{text}"
      elsif type == "warn" || type == "orange" || type == "thought"
        echo "!! #{text}"
      elsif type == "info" || type == "teal" || type == "whisper"
        echo "-- #{text}"
      elsif type == "green" || type == "speech"
        echo ">> #{text}"
      else
        echo text
      end
    end
  end

  def self.room_meta(key)
    key = "meta:#{key}"
    tag = Room.current.tags.find { |t| t =~ /#{key}/ }
    return Regexp.last_match(1).to_s if tag =~ /^#{key}:(.*)$/

    nil
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.wait_for_disk
    return unless ELoot.data.disk

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ }
      ELoot.msg("info", "waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ })
        sleep(0.1)
      end
    end

    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    res = dothistimeout("look in ##{ELoot.data.disk.id}", 3, /In the|There is nothing|That is closed/)
    return unless res =~ /That is closed/

    fput("open ##{ELoot.data.disk.id}")
    fput("look in ##{ELoot.data.disk.id}")
  end

  def self.change_stance(stance)
    return if Spell['Frenzy'].active? || dead?
    return if checkstance(stance.strip)
    return if stance == 'defensive' && checkstance('guarded')

    while (cur_stance = checkstance) != stance
      res = dothistimeout("stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
      elsif res =~ /Your rage causes you/
        Spell['Frenzy'].putup
        Spell['Frenzy'].timeleft = 30
      elsif cur_stance == 'guarded' && stance == 'defensive'
        break
      end
    end
  end

  def self.drag(from, to)
    ELoot.phase_box(from) if from.class == GameObj && from.type =~ /box/ && to != ELoot.data.disk

    input_to_id = proc do |input|
      next input if %w[drop wear].include?(input)
      next "##{input.id}" if input.class == GameObj
      next GameObj.right_hand.id.nil? ? 'right' : 'left' if input == 'hand'

      if input.class == String
        next "##{input.to_i}" unless input.to_i.zero?
        sack = find_sack(input)
        if sack.nil?
          ELoot.msg("info", "failed to find sack for #{input}")
          sack = find_sack('default')
        end
        next "##{sack.id}"
      end

      ELoot.msg("error", "invalid param #{input.inspect} passed to drag")
    end

    ELoot.msg("debug", "dragging #{from.inspect} to #{to.inspect}")

    to_id = input_to_id.call(to)
    from_id = input_to_id.call(from)

    if to_id.nil? || from_id.nil?
      ELoot.msg("error", "there was an issue dragging #{from_id} to #{to_id}")
      return
    end

    ELoot.msg("debug", "#{from_id.inspect} to #{to_id.inspect}")
    # Demandred - let's try changing this to dothistimeout - included aelotoi wings thing
    # fput("_drag #{from_id} #{to_id}")
    dothistimeout "_drag #{from_id} #{to_id}", 5, /^You|^Spreading your wings|^Draping the /

    lines = reget.reverse[0..3]

    # was it closed?
    if lines.any? { |l| l =~ /It's closed|That is closed/i }
      #      @sacks_to_close.push(to_id)
      fput("open #{to_id}")
      drag(from, to)
    elsif lines.any? { |l| l =~ /There appears to be an/i }
      ELoot.msg("info", "Possibly an item you want to keep")
      ELoot.msg("info", "Sleeping for 10 seconds: ;kill the script to hold onto it")
      sleep(10)
      drag(from, to)
    elsif lines.any? { |l| l =~ /won't fit in the/ && l !~ /#{XMLData.name} (?:disk|coffin)/ } #&& !overflow_attempted
      if ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", "You have not set an OVERFLOW container.")
        ELoot.msg("info", "Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop #{from_id}")
      else
        ELoot.msg("info", "Your STOW container is full. Attempting to store in overflow.")
        overflow_attempted = ELoot.find_sack(ELoot.data.settings[:overflow_container])
        res = fput("_drag #{from_id} ##{overflow_attempted.id}")
        if res =~ /won't fit in the/
          ELoot.msg("info", "Your OVERFLOW container cannot hold this item.")
          ELoot.msg("info", "Sleeping for 3 seconds: ;kill the script to handle yourself")
          sleep(3)
          fput("drop #{from_id}")
        end
      end
    end
    unless @sacks_to_close.empty?
      @sacks_to_close.uniq.each do |sack|
        fput("close #{sack}")
        @sacks_to_close.pop
      end
    end

  end

  def self.find_skinner(type)
    case type
    when :normal
      weapon_name = ELoot.data.settings[:skin_weapon]
    when :blunt
      weapon_name = ELoot.data.settings[:skin_weapon_blunt]
    end

    return nil if weapon_name.empty?
    return ELoot.data.skinners[type] if ELoot.data.skinners[type]

    unless ELoot.data.skinsheath
      unless ELoot.data.settings[:skin_sheath].empty?
        ELoot.data.skinsheath = GameObj.inv.find do |i|
          i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/ ||
            i.noun =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/
        end
      end

      ELoot.data.skinsheath ||= find_sack('default')
    end

    dothistimeout("look in ##{ELoot.data.skinsheath.id}", 3, /In the/) unless ELoot.data.skinsheath.contents

    items = ELoot.data.skinsheath.contents.clone
    items.push(GameObj.right_hand)
    items.push(GameObj.left_hand)

    weapon = items.find do |c|
      next if c.nil? || c.id.nil?

      c.name =~ /#{weapon_name}/i || c.noun =~ /\b#{weapon_name}\b/i
    end

    unless weapon
      ELoot.msg("info", "failed to find skinner: #{weapon_name} in #{ELoot.data.skinsheath}")
      return nil
    end

    ELoot.data.skinners[type] = weapon
    ELoot.data.skinners[type]
  end

  def self.find_sack(type = 'default')
    type = 'default' unless ELoot.data.sacks[type]
    ELoot.msg("debug", "ELoot.find_sack: type=#{type} sack=#{ELoot.data.sacks[type]}")

    res = dothistimeout("look in ##{ELoot.data.sacks[type].id}", 3, /In the|There is nothing|That is closed|shut too tightly/) if ELoot.data.sacks[type].contents.empty? or ELoot.data.sacks[type].contents.nil?

    if res =~ /It's closed|That is closed|shut too tightly/
      dothistimeout("open ##{ELoot.data.sacks[type].id}", 3, /^You |^Spreading your wings/)
      @sacks_to_close.push("##{ELoot.data.sacks[type].id}")
	  dothistimeout("look in ##{ELoot.data.sacks[type].id}", 3, /In the|There is nothing/) if ELoot.data.sacks[type].contents.empty? or ELoot.data.sacks[type].contents.nil?
    end

    ELoot.data.sacks[type]
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg("info", "Your current status prevents you from looting.")
      return
    end

    ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    ELoot.msg("debug", "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg("debug", "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg("debug", "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg("debug", "ELoot.loot: Looting the Room")
    Loot.room
  end

  def self.help
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", "ELoot by SpiffyJr, maintained by Elanthia-Online")
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", "ELoot is a looter script designed to make looting as fast and easy as possible.")
    ELoot.msg("yellow", "")
    ELoot.msg("teal",   "Basic usage: #{$lich_char}eloot")
    ELoot.msg("yellow", "")
    ELoot.msg("green",  "Extra commands:")
    ELoot.msg("teal",   "  help        shows this help message")
    ELoot.msg("teal",   "  left|right  loots your left/right hand")
    ELoot.msg("teal",   "  list        lists current settings")
    ELoot.msg("teal",   "  sell        sells your default loot sack")
    ELoot.msg("yellow", "")
  end

  def self.go2(place)
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.class == String && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      if ELoot.data.settings[:debug]
        ELoot.msg "info", "unknown room location: hope you know what you're doing"
      else
        ELoot.msg "error", 'unknown room location'
      end
    end
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def self.withdraw_silver(amount)
    return if amount <= 0

    ELoot.go2('bank')

    # TODO: handle not enough silver case
    fput("withdraw #{amount} silvers")
  end

  def self.check_silver
    silvers = nil
    started = false
    silver_end = nil
    # Let's stir it up and get notes and stuff, too, using wealth quiet.
    action = proc do |server_string|
      if server_string =~ /You have (no silver|but one|[,0-9]+) coins? with you\./
        started = true
        if $1 == "no silver"
          silvers = 0
        elsif $1 == "but one"
          silvers = 1
        else
          silvers = $1.delete(",").to_i
        end
        nil
      elsif server_string =~ /You are carrying .+ valued at a total of ([,\d]+) silver\./
        nil
      elsif server_string =~ /You are carrying .+ between notes and coins\./
        nil
      elsif server_string =~ /<prompt time=/ && started == true
        DownstreamHook.remove('eloot_check_silvers')
        nil
      else
        server_string
      end
    end

    DownstreamHook.add('eloot_check_silvers', action)
    $_SERVER_.puts "#{$cmd_prefix}wealth quiet\n"
    wait_until { silvers }
    silvers
  end

  def self.fill_hands
    ELoot.data.stored = [] unless GameObj.left_hand.id.nil? || GameObj.right_hand.id.nil?

    return if ELoot.data.stored.empty?

    ELoot.data.stored.each do |obj|
      if (rdy = ELoot.data.ready_list.find { |_, name| name.include?(obj.name) })
        fput("ready #{rdy[0]}")
      else
        fput("get ##{rdy[0]}")
      end
    end

    ELoot.data.stored = []
  end

  def self.free_hands
    ELoot.free_hand('right')
    ELoot.free_hand('left')
  end

  def self.free_hand(hand = 'right')
    obj = hand == 'right' ? GameObj.right_hand : GameObj.left_hand

    return if obj.id.nil? || GameObj.left_hand.id.nil?

    add_it = proc do |to_store|
      next if ELoot.data.stored.any? { |_, o| o.id == to_store.id }

      ELoot.data.stored.push(to_store).uniq!
    end

    did_it = proc do
      next true if hand == 'right' && GameObj.right_hand.id.nil?
      next true if hand == 'left' && GameObj.left_hand.id.nil?

      next false
    end

    done = false

    ["store #{hand}", "stow #{hand}"].each do |cmd|
      waitrt?
      put(cmd)

      30.times do
        line = get?
        break if line =~ /Could not figure out/

        if line =~ /...wait/
          waitrt?
          put(cmd)
          next
        end

        if did_it.call
          done = true
          add_it.call(obj)
          break
        end

        sleep(0.10)
      end

      break if done
    end
  end

  def self.find_boxes
    ELoot.wait_for_disk
    ELoot.msg("debug", "find_boxes: ELoot.data.disk is #{ELoot.data.disk}")
    if ELoot.data.disk
      disk_contents = ELoot.data.disk.contents.to_a
      ELoot.msg("debug", "find_boxes: disk_contents found")
    else
      disk_contents = []
      ELoot.msg("debug", "find_boxes: disk_contents empty")
    end
    if ELoot.data.settings[:overflow_container].empty?
      overflow_box_contents = []
      ELoot.msg("debug", "find_boxes: overflow_box_contents empty")
    else
      overflow_box_contents = ELoot.find_sack(ELoot.data.settings[:overflow_container].to_s).contents.to_a
      ELoot.msg("debug", "find_boxes: overflow_box_contents found")
    end
    default_contents = ELoot.find_sack('default').contents.to_a
    ELoot.msg("debug", "find_boxes: default_contents found") if default_contents
    box_contents = ELoot.find_sack('box').contents.to_a
    ELoot.msg("debug", "find_boxes: box_contents found") if box_contents
    box_list = (default_contents + box_contents + disk_contents + overflow_box_contents).find_all { |obj| obj.type =~ /box/ }.uniq
  end

  def self.phase_box(box)
    return box unless ELoot.data.settings[:loot_phase] && Spell[704].known? && box.name !~ /enruned|mithril/i

    # ELoot.free_hand
    if !checkright.nil? && !checkleft.nil?
      empty_hand
    end

    ELoot.drag(box, 'hand') unless [GameObj.left_hand.id, GameObj.right_hand.id].include?(box.id)
    waitcastrt?

    dothistimeout('prep 704', 3, /Your spell is ready/)
    phase_match = /appears lighter|somewhat insubstantial|flickers in and out|resists the effects/
    res = dothistimeout("cast ##{box.id}", 3, phase_match)

    # once phased they get a new id so refresh the object
    return box unless res =~ /appears lighter/

    GameObj.left_hand.type =~ /box/i ? GameObj.left_hand : GameObj.right_hand
  end

  def self.unphase_box(box)
    return box unless box.type == 'box' && box.name =~ /shifting/i

    res = dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    return box unless res =~ /flickers in and out of existence/

    GameObj.left_hand.type =~ /box/i ? GameObj.left_hand : GameObj.right_hand
  end

  # Global data used by ELoot
  class Data
    attr_accessor :disk, :disk_full, :stored, :ready_list, :sacks, :settings, :skinners, :skinsheath

    def initialize(settings)
      @disk = nil
      @disk_full = false
      @ready_list = {}
      @sacks = {}
      @settings = settings
      @skinners = {}
      @skinsheath = nil
      @stored = []

      waitrt?
      res = dothistimeout('ready list', 3, /Your current settings are/)
      ELoot.msg("error", "failed to check READY list; restart me") if res !~ /Your current settings/

      res = dothistimeout('stow list', 3, /You have the following/)
      sleep 0.2
      ELoot.msg("error", "failed to check STOW list; restart me") if res !~ /You have the following/

      ready_list_match = /(?:shield|weapon):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="\d+"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>/
      container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
      $_SERVERBUFFER_.reverse[0..50].each do |line|
        if line =~ ready_list_match
          @ready_list.store(Regexp.last_match(1).to_s.downcase, Regexp.last_match(2).to_s.downcase)
          nil
        elsif line =~ container_match
          #          next if Regexp.last_match(1).empty? || Regexp.last_match(1).nil?
          @sacks.store(Regexp.last_match(2), GameObj.inv.find { |i| i.id == Regexp.last_match(1) })
          @sacks.delete(Regexp.last_match(2)) unless @sacks[Regexp.last_match(2)]
        end
      end

      ELoot.msg("error", "Set stow container using STOW SET before using this script") if @sacks['default'].nil?
      ELoot.msg("info", "checking for existence of disk")
      15.times do
        break if (@disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} disk$/ })

        sleep(0.1)
      end

      @disk ? ELoot.msg("info", "disk found") : ELoot.msg("info", "no disk found")

      ELoot.msg("debug", "ready list: #{@ready_list.inspect}")
      ELoot.msg("debug", "sacks: #{@sacks.inspect}")

      DownstreamHook.add('eloot-disk',
        proc do |line|
          next line if @disk

          if line =~ %r{Your <a exist="(\d+)" noun="disk">disk</a> arrives, following you dutifully.}
            @disk_full = false if @disk.nil
            @disk = GameObj.loot.find { |obj| obj.id == Regexp.last_match(1).to_s }
          end
          line
        end
      )
    end
  end

  # Setup is an extension of Gtk::Builder for Gtk setup
  class Setup < Gtk::Builder
    @@categories = {
      loot: {
        loot_types: {
        #:loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        loot_exclude: {
        #:loot_exclude=>["black ora", "urglaes"],
          default: ["black ora", "urglaes"],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        loot_phase: { default: false },
        #:loot_phase=>false,
        loot_defensive: { default: false },
        #:loot_defensive=>false,
        overflow_container: { default: '' }
        #:overflow_container=>"",
      },
      sell: {
        sell_loot_types: {
        #:sell_loot_types=>["alchemy", "armor", "clothing", "collectible", "gem", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        sell_exclude: {
        #:sell_exclude=>[],
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        sell_keep_scrolls: {
        #:sell_keep_scrolls=>[],
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = Spell[text].num
              iter[1] = Spell[text].name
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(Spell[selected.get_value(0)].num)
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)
            next if Spell[text].nil?

            setting.push(Spell[text].num)
            setting.uniq!.sort!
          end
        },
        sell_appraise_types: {
        #:sell_appraise_types=>["jewelry", "magic", "uncommon", "valuable"],
          default: ["jewelry", "magic", "uncommon", "valuable"]
        },
        sell_appraise_gemshop: { default: 14_999 },
        #:sell_appraise_gemshop=>14999,
        sell_appraise_pawnshop: { default: 34_999 },
        #:sell_appraise_pawnshop=>34999,
        sell_collectibles: { default: true },
        #:sell_collectibles=>true,
        sell_gold_rings: { default: false },
        #:sell_gold_rings=>false,
        sell_locksmith: { default: false },
        #:sell_locksmith=>false,
        sell_locksmith_pool: { default: true },
        #:sell_locksmith_pool=>true,
        sell_locksmith_pool_tip: { default: 15 },
        #:sell_locksmith_pool_tip=>15,
        sell_locksmith_pool_tip_percent: { default: true },
        #:sell_locksmith_pool_tip_percent=>true,
        sell_share_silvers: { default: false },
        #:sell_share_silvers=>false,
        sell_fwi: { default: false },
        #:sell_fwi=>false,
        sell_keep_silver: { default: 0 }
        #:sell_keep_silver=>0,
      },
      skin: {
        skin_enable: { default: false },
        #:skin_enable=>false,
        skin_kneel: { default: false },
        #:skin_kneel=>false,
        skin_604: { default: false },
        #:skin_604=>false,
        skin_resolve: { default: false },
        #:skin_resolve=>false,
        skin_sheath: { default: '' },
        #:skin_sheath=>"",
        skin_weapon: { default: '' },
        #:skin_weapon=>"",
        skin_weapon_blunt: { default: '' }
        #:skin_weapon_blunt=>"",
      },
      internal: {
        silence: { default: true },
        #:silence=>true,
        debug: { default: false },
        #:debug=>false,
        unskinnable: { default: [] }
        #:unskinnable=>[]
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()

      @settings = settings

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

      # only sorcerers can phase
      @settings[:loot_phase] = false unless Char.prof == 'Sorcerer'

      # 604 support
      @settings[:skin_604] = false unless Spell[604].known?

      # GoS only for Sigil of Resolve
      @settings[:skin_resolve] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 4

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        add_from_file("#{$data_dir}eloot.ui")
        load_settings

        self['main'].keep_above = true
        self['main'].set_title "ELoot Setup v#{ELoot_version}"

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update

          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        end
      end
    end

    def on_close_clicked
      ELoot.save_profile()
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue { @running = false }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_resolve")) && !Spell[9704].known?
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_604")) && !Spell[604].known?
          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          next if Setup.get_setting(key).nil?

          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true

      Gtk.queue { self['main'].show_all }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def update_setting(key, value)
      setting = Setup.get_setting(key)
      ELoot.msg("error", "** setting \"#{key}\" does not exist") if setting.nil?

      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        ELoot.msg("info", "reset #{key}")
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          ELoot.msg("info", "\"#{value}\" removed from \"#{key}\"")
        else
          @settings[key].push(value)
          ELoot.msg("info", "\"#{value}\" added to \"#{key}\"")
        end

        ELoot.msg("info", "\"#{key}\" is now \"#{@settings[key].join(', ')}\"")
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        ELoot.msg("info", "set \"#{key}\" to \"#{value}\"")
        @settings[key] = value
      end
    end
  end

  # Loot handles the loot routine for ELoot
  module Loot
    def self.reject_invalid_loot(objs)
      objs.reject do |obj|
        obj.name =~ /\bsevered\b/i ||
          obj.id.to_i.negative? ||
          (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon/i) # Demandred - uncommon added
      end
    end

    def self.valid_objs(objs)
      if !ELoot.data.settings[:loot_types].nil?
        objs.reject do |obj|
          obj.type !~ Regexp.union(ELoot.data.settings[:loot_types]) ||
            (ELoot.data.settings[:loot_exclude].length.positive? &&
             obj.name =~ Regexp.union(ELoot.data.settings[:loot_exclude]))
        end
      end
    end

    def self.invalid_objs(objs)
      objs.find_all do |obj|
        (obj.type =~ /cursed/ && !ELoot.data.settings[:loot_types].include?('cursed')) \
        || (ELoot.data.settings[:loot_exclude].length.positive? \
        && obj.name =~ Regexp.union(ELoot.data.settings[:loot_exclude]))
      end
    end

    def self.box(box)
      trash_match = /(?:crate|barrel|wastebarrel|wastebasket|casket|coffer)$/
      trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| (obj.noun =~ trash_match && obj.name !~ /with \w+'s #{obj.noun}$/)}

      res = dothistimeout("open ##{box.id}", 3, /open|locked/)
      return ELoot.drag(box, 'box') if res =~ /locked/

      if box.contents.nil?
        dothistimeout("look in ##{box.id}", 3, /In the/)
        30.times do
          break unless box.contents.nil?

          sleep(0.10)
        end
      end

      if box.contents.nil?
        ELoot.msg("info", "failed to see contents of #{box.name}")
        ELoot.drag(box, 'box')
        return
      end

      if box.contents.any? { |obj| obj.name =~ /silver coins/ }
        res = dothistimeout("get coins from ##{box.id}", 3, /You gather the remaining|Get what\?/)
        ELoot.msg("info", "unknown get coin result") if res !~ /You gather the remaining/
      end

      waitrt?

      Loot.objs(box.contents,
        proc do
          empty_left_hand if !GameObj.left_hand.id.nil?
          res = dothistimeout("loot ##{box.id}", 3, /You search through/)
          ELoot.msg("info", "failed to LOOT box") if res.nil?
          sleep(0.10)

          if box.contents.length.positive?
            lootsack = ELoot.data.sacks('default')

            res = dothistimeout("empty ##{box.id} in ##{lootsack.id}", 3, /You try to empty/)
            ELoot.msg("info", "failed to EMPTY box") if res.nil?

            waitrt?
          end

          if box.contents.length.positive?
            ELoot.msg("info", "There appears to still be loot in your box. You should handle this manually.")
            ELoot.msg("info", "You have 5 seconds to kill me.")
            sleep(5)
          end
        end
      )

      if trash.nil?
        ELoot.drag(box, 'drop')
      else
        fput("put ##{box.id} in ##{trash.id}")
        sleep(0.25)
        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
          fput("put ##{box.id} in ##{trash.id}")
          sleep(0.25)
        end
      end

      ELoot.drag(box, 'drop') if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
    end

    def self.obj(obj)
      obj_refill_hand = false
      if !checkright.nil? && !checkleft.nil?
        empty_hand
        obj_refill_hand = true
      end
      # Special handling for boxes
      if obj.type == 'box'
        return ELoot.drag(obj, 'box') unless ELoot.data.disk && !ELoot.data.disk_full

        # Wait for disk to arrive
        ELoot.wait_for_disk

        # Disk didn't make it - abort
        if ELoot.data.disk.status =~ /gone/
          ELoot.drag(obj, 'box')
          return
        end

        # Disk found. Give it a shot.
        ELoot.drag(obj, ELoot.data.disk)

        # Welp, it's full, stow in normal container instead
        if reget.reverse[0..10].any? { |l| l =~ /is full|won't fit in the/i }
          ELoot.data.disk_full = true
          ELoot.drag(obj, 'box')
        end

        return
      end

      # we know some types don't work with LOOT
      if obj.type !~ /box|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic/
        return ELoot.drag(obj, obj.type)
      end

      # use built-in loot command
      loot_match = /You pick up|does not appear to be|There is no loot/
      res = dothistimeout("loot ##{obj.id}", 3, loot_match)
      # failed, stow in default container
      return ELoot.drag(obj, obj.type) if res =~ /does not appear to be/

      # still in hand for some reason (probably won't fit)
      return unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(obj.id)

      ELoot.msg("info", "item won't fit in your container")
      ELoot.msg("info", 'sleeping for 3 seconds; kill me if you want to keep it')
      sleep(3)
      ELoot.drag(obj, 'drop')

      if obj_refill_hand
        fill_hand
      end
    end

    def self.room
      Loot.objs(GameObj.loot.to_a,
        proc do
          # ELoot.free_hand
          if !checkright.nil? && !checkleft.nil?
            empty_hand
          end
          res = dothistimeout('loot room', 3, /With a discerning eye|There is no loot|(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/)
          if res =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/
            temp_sack = ELoot.find_sack(ELoot.data.settings[:overflow_container].to_s)
            if res =~ /but quickly realize/
              checkright.nil? ? temp_id = GameObj.left_hand.id : temp_id = GameObj.right_hand.id
              fput("_drag ##{temp_id} ##{temp_sack.id}")
            else
              fput("_drag ##{GameObj.left_hand.id} ##{temp_sack.id}")
              fput("_drag ##{GameObj.right_hand.id} ##{temp_sack.id}")
            end
          end
#          fill_hand
        end
      )
	  fill_hand
    end

    def self.objs(objs, routine)
      objs = Loot.reject_invalid_loot(objs)

      return if objs.empty?

      # Boxes go first. If handled, we reject them since they're already looted.
      objs = objs.reject do |obj|
        next false unless obj.type == 'box' || obj.type == 'collectible' || (obj.type =~ /weapon|armor/i && obj.type =~ /uncommon/ && (ELoot.data.settings[:loot_exclude].length.positive? && obj.name !~ Regexp.union(ELoot.data.settings[:loot_exclude])))

        Loot.obj(obj)
        next true
      end

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      return if objs.empty?

      # Find out what loot is valid so we can match it to the remaining room loot
      valid = Loot.valid_objs(objs.clone) if not objs.empty?
      invalid = Loot.invalid_objs(objs.clone) if not objs.empty?

      # Is there anything else we care about?
      return if valid.empty?

      # Demandred - fix excluded loot section
      if invalid.empty?
        routine.call(valid)
      else
        valid.each do |obj|
          Loot.obj(obj)
        end
      end
    end

    def self.search(objs = GameObj.dead.to_a)
      return if objs.empty?

      search_refill_hand = false

      if objs.any? { |o| o.name =~ /skayl/ }
        if !checkright.nil && !checkleft.nil?
          empty_hand
        end
      end

      objs.each do |obj|
        ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]

        # Loot it
        3.times do
          waitrt?
          res = dothistimeout("loot ##{obj.id}", 1, /You search/)
          break if res =~ /You search/ || obj.status =~ /gone/ || obj.nil?
        end

        # Some creatures put an item directly in your hand
        if obj.name =~ /skayl/
          Loot.obj(GameObj.right_hand)
        end
      end

      if search_refill_hand
        fill_hand
      end

      # if the setting is on always end in defensive
      ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type)
      return if objs.empty?

      # Set some stuff up to fix skinning for blunt since it requires two hands(one empty)
      swap_back_blunt = false
      normal_fill_hand = false
      blunt_fill_hands = false
      blunt_fill_right_hand = false
      blunt_fill_left_hand = false

      # Find our skinner
      skinner = ELoot.find_skinner(type)
      has_skinner = skinner.nil? || [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

      if type == :normal
        if !has_skinner && !checkright.nil? && !checkleft.nil?
          empty_hand
          normal_fill_hand = true
        end
      elsif type == :blunt
        if !has_skinner
          empty_hands
          blunt_fill_hands = true
        else
          if GameObj.right_hand.id == skinner.id
            if !GameObj.left_hand.id.nil?
              empty_left_hand
              blunt_fill_left_hand = true
            end
          elsif GameObj.left_hand.id == skinner.id
            if !GameObj.right_hand.id.nil?
              empty_right_hand
              blunt_fill_right_hand = true
              fput "swap"
              swap_back_blunt = true
            end
          end
        end
      end

      unless has_skinner
        # ELoot.free_hand
        until [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
          waitrt?
          ELoot.drag(skinner, 'hand')
          pause 0.2
        end
        now_has_skinner = [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
          Spell['Sigil of Resolve'].affordable? &&
          !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = /
      You[ ]skinned|
      You[ ]botched|
      already[ ]been|
      cannot[ ]skin|
      must[ ]be[ ]a[ ]member|
      can[ ]only[ ]skin|
      You[ ]are[ ]unable[ ]to[ ]break[ ]through|
      You[ ]break[ ]through[ ]the[ ]crust[ ]of[ ]the|
      You[ ]crack[ ]open[ ]a[ ]portion|
      Because[ ]your[ ]account[ ]is[ ]free
      /x

      break_match = /
      (?:
       You[ ]break[ ]through[ ]the[ ]crust[ ]of[ ]the[ ].+[ ]and[ ]withdraw[ ]|
      You[ ]crack[ ]open[ ]a[ ]portion[ ]of[ ]the[ ].+[ ]and[ ]uncover[ ]
      )(.+)!
      /x

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id}#{(has_skinner || now_has_skinner) ? " #{skinner_hand}" : ''}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?
      ELoot.drag(skinner, ELoot.data.skinsheath) if !has_skinner
      if swap_back_blunt
        fput "swap"
      end
      fill_hand if normal_fill_hand
      fill_hands if blunt_fill_hands
      fill_right_hand if blunt_fill_right_hand
      fill_left_hand if blunt_fill_left_hand
    end

    def self.skin(objs = GameObj.dead.to_a)
      objs = objs.reject do |obj|
        ELoot.data.settings[:unskinnable].index(obj.name) > -1 ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      stance = checkstance
      ELoot.change_stance('offensive') if GameObj.targets.empty?
      dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
      ELoot.change_stance(stance) if checkstance != stance
    end
  end

  # Sell is a module that handles selling loot
  module Sell

    @default_sack = ELoot.find_sack('default')
    @overflow_sack = ELoot.find_sack(ELoot.data.settings[:overflow_container]) if !ELoot.data.settings[:overflow_container].nil?

    def self.gold_rings
      rings = {}
      unless ELoot.data.sacks["jewelry"].nil?
        sack = ELoot.data.sacks["jewelry"]
      else
        sack = @default_sack #ELoot.data.sacks["default"]
      end
      rings = sack.contents.find_all { |item| item.name =~ /^(\w+) gold ring$/ }

      return if rings.empty?

      ELoot.go2("chronomage")
      unless npc = GameObj.npcs.find { |npc| npc.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant/ }
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant/ }
      end
      unless npc.nil?
        empty_hands

        rings.each { |ring|
          fput "get ##{ring.id}"
          fput "give ##{ring.id} to ##{npc.id}"

          if checkleft or checkright
            fput "put ##{ring.id} in my ##{sack.id}"
          end
        }

        fill_hands
      end
    end

    def self.bounty_tasks
      # rubocop:disable Layout/LineLength
      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./
      # gem_match
      # heirloom_match
      # herb_match

      # rubocop:enable Layout/LineLength

      if bounty? =~ skin_match
        skin = Regexp.last_match(2)
        realm = Regexp.last_match(3).nil? ? Regexp.last_match(4) : Regexp.last_match(3)

        furrier = Room.list.find { |r| r.tags.include?('furrier') && r.location =~ /#{realm}/i }
        error('failed to find the furrier to turn into; send this to Elanthia-Online') unless furrier

        loot = ELoot.find_sack('skin').contents.find_all { |l| l.sellable == 'furrier' && skin =~ /#{l.name}/ }
        unless loot.empty?
          ELoot.go2(furrier)
          loot.each do |l|
            ELoot.drag(l, 'hand')
            fput("sell ##{l.id}")
          end
        end
      end
    end

    def self.locksmith_open(box, activator)
      ELoot.drag(box, 'hand')
      box = ELoot.unphase_box(box)

      res = dothistimeout(activator, 3, /Gimme ([\d,]+) silvers/)
      ELoot.msg "info", 'unknown locksmith response' unless res

      res = dothistimeout('pay', 3, /accepts|have enough/)
      if res =~ /have enough/
        ELoot.drag(box, 'default')
        ELoot.withdraw_silver(8000 - ELoot.check_silver)
        ELoot.go2('locksmith')

        return Sell.locksmith_open(box, activator)
      end

      Loot.box(box)
    end

    def self.locksmith_pool(boxes)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false
      ELoot.withdraw_silver(8000 - ELoot.check_silver) if boxes.length.positive?
      ELoot.go2('locksmith pool')

      if (worker = GameObj.npcs.find { |npc| npc.name == ELoot.room_meta('boxpool:npc') }).nil?
        ELoot.msg("info", "failed to find the locksmith pool NPC")
        ELoot.msg("info", "update your map db; ;repository download-mapdb")
        ELoot.msg("info", "if the error persists then report this to Elanthia-Online")
        return
      end

      empty_right_hand
      ELoot.wait_for_disk

      boxes.each do |box|
        ELoot.drag(box, 'hand')
        # give_box.call(box)
        box = ELoot.unphase_box(box)
        if ELoot.data.settings[:sell_locksmith_pool_tip_percent]
          percent = ' PERCENT'
        else
          percent = ''
        end

        fput("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}")
        match = /You don't have that much|takes your|already holding as many boxes/
        res = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
        if res =~ /You don't have that much/
          ELoot.withdraw_silver(8000 - ELoot.check_silver)
          ELoot.go2('locksmith pool')
          give_box.call(box)
        elsif res =~ /already holding as many boxes/
          sleep(0.250)
          ELoot.drag(box, 'box') if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
          break
        end
        sleep(0.250)
        ELoot.drag(box, 'box') if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      end

      # retrieve (and loot) any boxes in the pool
      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)
        # no more boxes left
        break if res !~ /Alright, here's your/

        box = nil
        if GameObj.right_hand.type =~ /box/
          box = GameObj.right_hand
        elsif GameObj.left_hand.type =~ /box/
          box = GameObj.left_hand
        else
          error('failed to find the box you were supposed to get; report this to Elanthia-Online')
        end

        Loot.box(box)

        sleep(0.250)
      end
    end

    def self.locksmith(boxes)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      boxes = boxes.select { |box| box.type =~ /box/i }

      return if boxes.empty?

      silver = ELoot.check_silver

      ELoot.withdraw_silver(8000 - silver) if silver < 8000

      ELoot.go2('locksmith')
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            # ELoot.free_hands
            empty_hands
            boxes.each { |box| Sell.locksmith_open(box, activator) }

            ELoot.drag(GameObj.right_hand, 'drop') if GameObj.right_hand.type =~ /box/

            ELoot.drag(GameObj.left_hand, 'drop') if GameObj.left_hand.type =~ /box/
          else
            ELoot.msg("error", "failed to find a bell, keys, or chime on the table")
          end
        end
      else
        ELoot.msg("error", "failed to find a table")
      end
    end

    def self.collectibles
      cols = []
      if ELoot.data.settings[:sell_collectibles]
        cols += @default_sack.contents.find_all { |l| l.type =~ /collectible/ }
        cols += ELoot.find_sack('collectible').contents.find_all { |l| l.type =~ /collectible/ } if ELoot.data.sacks.include?('collectible') # [:sell_loot_types].include?('collectible')
      end
      return if cols.empty?

      ELoot.go2('collectibles')

      cols.each do |c|
        ELoot.drag(c, 'hand')
        dothistimeout("deposit ##{c.id}", 3, /You hand your/)
      end
    end

    def self.stow_notes
      ELoot.drag(GameObj.right_hand, 'default') if GameObj.right_hand.noun =~ /(?:note|scrip|chit)$/
      ELoot.drag(GameObj.left_hand, 'default') if GameObj.left_hand.noun =~ /(?:note|scrip|chit)$/
    end

    def self.sell
      fput('unhide') if (hidden? || invisible?)
      @sell_ignore ||= []

      # ELoot.free_hands
      empty_hands

      # check for bounties
      Sell.bounty_tasks

      ELoot.msg("debug", "ELoot.sell: Locating boxes")
      boxes = ELoot.find_boxes
      cur_len = boxes.length.to_i
      ELoot.msg("debug", "ELoot.sell: Boxes length = #{cur_len}")

      if ELoot.data.settings[:sell_locksmith_pool] && boxes.length.positive?
        Sell.locksmith_pool(boxes)

        # refresh the boxes
        boxes = ELoot.find_boxes
      end

      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?
      Sell.collectibles if ELoot.data.settings[:sell_collectibles]
      Sell.gold_rings if ELoot.data.settings[:sell_loot_types].include?('jewelry') # ELoot.data.settings[:sell_gold_rings]

      sell_items = []

      ELoot.data.settings[:sell_loot_types].each { |type|
        lootsack = ELoot.find_sack("#{type}") if ELoot.data.sacks.include?("#{type}")
        lootsack.contents.each { |obj|
          next if (obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if obj.type !~ /#{type}/
          next if obj.name =~ /^(\w+) gold ring$/ # We already determined gold ring status
          next if @sell_ignore.include?(obj.id)
          next if sell_items.include?(obj.id)

          sell_items.push(obj)
        }
      }
#        lootsack = ELoot.find_sack('default')
        lootsack = @default_sack
        ELoot.data.settings[:sell_loot_types].each { |type|
          lootsack.contents.each { |obj|
            next if (obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
            next if obj.type !~ /#{type}/
            next if obj.name =~ /^(\w+) gold ring$/ # We already determined gold ring status
            next if @sell_ignore.include?(obj.id)
            next if sell_items.include?(obj.id)

            sell_items.push(obj)
          }
        }
#        lootsack = ELoot.find_sack(ELoot.data.settings[:overflow_container]) if !ELoot.data.settings[:overflow_container].nil?
        lootsack = @overflow_sack
        ELoot.data.settings[:sell_loot_types].each { |type|
          lootsack.contents.each { |obj|
            next if (obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
            next if obj.type !~ /#{type}/
            next if obj.name =~ /^(\w+) gold ring$/ # We already determined gold ring status
            next if @sell_ignore.include?(obj.id)
            next if sell_items.include?(obj.id)

            sell_items.push(obj)
          }
        }

      ELoot.msg("debug", "List of items to be sold")
      pp sell_items if ELoot.data.settings[:debug]

      get_loot = proc do |location|
        sell_items.find_all { |obj| obj.sellable =~ /#{location}/i }
      end

      # do the primary selling at each place
      %w[furrier gemshop consignment pawnshop].each do |location|
        loot = get_loot.call(location).uniq

        pp location if ELoot.data.settings[:debug]
        pp loot if ELoot.data.settings[:debug]

        next if loot.empty? or loot.nil?

        ELoot.go2(location)

        if ((location =~ /furrier/ && (ELoot.data.settings[:sell_loot_types].include?('skin')))) # ||
          ELoot.data.sacks.include?('skin') ? skinsack = ELoot.find_sack('skin') : skinsack = @default_sack #ELoot.find_sack('default')
          unless (skinsack.contents.find_all { |obj| obj.type =~ /skin/ }).empty?
            ELoot.drag(skinsack, 'hand') if [checkleft, checkright].index(skinsack.noun).nil?
            dothistimeout("sell ##{skinsack.id}", 3, /inspects the contents carefully/)
            ELoot.drag(skinsack, 'wear') unless [checkleft, checkright].index(skinsack.noun).nil?
          end
          Sell.stow_notes
          unless ELoot.data.settings[:overflow_container].empty?
            skinsack = ELoot.find_sack(ELoot.data.settings[:overflow_container])
            unless (skinsack.contents.find_all { |obj| obj.type =~ /skin/ }).empty?
              ELoot.drag(skinsack, 'hand') if [checkleft, checkright].index(skinsack.noun).nil?
              dothistimeout("sell ##{skinsack.id}", 3, /inspects the contents carefully/)
              ELoot.drag(skinsack, 'wear') unless [checkleft, checkright].index(skinsack.noun).nil?
            end
          end
          sell_items.reject! { |obj| obj.type =~ /skin/ } # sold in bulk so zero out skins
          Sell.stow_notes

          loot = get_loot.call(location)

          next if loot.empty?
        end

        if (location =~ /gemshop/ && (ELoot.data.settings[:sell_loot_types].include?('gem')))
          bulk_gems = false
          ELoot.data.sacks.include?('gem') ? gemsack = ELoot.find_sack('gem') : gemsack = @default_sack #ELoot.find_sack('default')
          if ELoot.data.settings[:sell_exclude].empty? || (gemsack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ }).empty?
            unless gemsack.contents.find_all { |obj| obj.type =~ /gem/ }.empty?
              bulk_gems = true
              ELoot.drag(gemsack, 'hand') if [checkleft, checkright].index(gemsack.noun).nil?
              res = dothistimeout("sell ##{gemsack.id}", 3, /inspects the contents carefully|Would you mind unlocking this for me please/)
              # auto-closing gem pouches exception
              if res =~ /Would you mind unlocking this for me please/
                fput("open ##{gemsack.id}")
                dothistimeout("sell ##{gemsack.id}", 3, /inspects the contents carefully/)
              end
              ELoot.drag(gemsack, 'wear') unless [checkleft, checkright].index(gemsack.noun).nil?
            end
          end
          Sell.stow_notes
          unless ELoot.data.settings[:overflow_container].nil?
            gemsack = ELoot.find_sack(ELoot.data.settings[:overflow_container])
            if ELoot.data.settings[:sell_exclude].empty? || (gemsack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ }).empty?
              unless gemsack.contents.find_all { |obj| obj.type =~ /gem/ }.empty?
                bulk_gems = true
                ELoot.drag(gemsack, 'hand') if [checkleft, checkright].index(gemsack.noun).nil?
                dothistimeout("sell ##{gemsack.id}", 3, /inspects the contents carefully/)
                ELoot.drag(gemsack, 'wear') unless [checkleft, checkright].index(gemsack.noun).nil?
              end
            end
          end
          Sell.stow_notes
          gemsack = @default_sack # ELoot.find_sack('default')
          if ELoot.data.settings[:sell_exclude].empty? || (gemsack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ }).empty?
            unless gemsack.contents.find_all { |obj| obj.type =~ /gem/ }.empty?
              bulk_gems = true
              ELoot.drag(gemsack, 'hand') if [checkleft, checkright].index(gemsack.noun).nil?
              dothistimeout("sell ##{gemsack.id}", 3, /inspects the contents carefully/)
              ELoot.drag(gemsack, 'wear') unless [checkleft, checkright].index(gemsack.noun).nil?
            end
          end
          Sell.stow_notes
          sell_items.reject! { |obj| obj.type =~ /gem/ } if bulk_gems
          bulk_gems = false

          loot = get_loot.call(location)

          next if loot.empty?
        end

        gem_pouch_open = false
        gem_pouch_was_opened = true
        loot.uniq.each do |obj|
          if @sell_ignore.include?(obj.id)
            echo "ignore included the id of something"
            next
          end
          if obj.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
            res = dothistimeout "read ##{obj.id}", 3, /On the/
            if res.nil?
              @sell_ignore.push(obj.id)
              next
            end

            spell_list = []
            $_SERVERBUFFER_.reverse[0..25].each do |line|
              if line =~ /noun="([0-9]+)"/
                spell_list.push(Regexp.last_match(1).to_i)
              elsif line =~ /On the <a exist="[^"]+"/
                break
              end
            end

            if (ELoot.data.settings[:sell_keep_scrolls] & spell_list).length.positive?
              @sell_ignore.push(obj.id)
              next
            end
          end

          ELoot.msg("debug", "Object type is #{obj.type.to_s}")
          if obj.type =~ /gem/ && ELoot.data.sacks.include?('gem')
            ELoot.msg("debug", "Gem sack is #{ELoot.data.sacks['gem']}")
            ELoot.msg("debug", "Object is Gem and gem stow sack set")
            # Always attempt to open the gem pouch once
            unless gem_pouch_open
              ELoot.msg("debug", "opening gem sack")
              gemsack = ELoot.find_sack('gem')
              res = dothistimeout("open ##{gemsack.id}", 3, /is already open|open/)
              gem_pouch_was_opened = false if res =~ /is already open/
              ELoot.msg("debug", "open message is #{res}")
              gem_pouch_open = true
            else
              ELoot.msg("debug", "gem_pouch_open is true")
            end
            ELoot.drag(obj, 'hand')
          else
            ELoot.drag(obj, 'hand')
          end

          # rubocop:disable Layout/LineLength
          high_value = /not buying anything this valuable today/
          denied = /Can't say I'm interested|That's basically worthless here|He hands it back to you, saying|Not my line, really|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|no use for that|Appraise what\?\?\?/
          appraised = /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/
          sold = /(?:pays|hands) you [,0-9]+ silver|I don't have that much spare silver, I will have to give you a bank note for it|I'm afraid I don't have that much silver on hand.+so I'll have to give you a .+ for it./
          item_selling_match = Regexp.union(high_value,denied,appraised,sold)
          # rubocop:enable Layout/LineLength

          unless ELoot.data.settings[:sell_appraise_types].empty?
            if obj.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/
              res = dothistimeout "appraise ##{obj.id}", 3, item_selling_match
              value = 99_999_999
              case location
              when 'gemshop'
                value = ELoot.data.settings[:sell_appraise_gemshop]
              when 'pawnshop'
                value = ELoot.data.settings[:sell_appraise_pawnshop]
              else
                ELoot.msg "info", "appraise setting not available for #{location}; report this to Elanthia-Online"
              end

              if res =~ appraised
                matched = $1.delete(",").to_i
                echo "price match is #{matched}"
              end

              # Adding too valuable to sell jewelry to ignore because some of it will be attempted to be sold at the pawnshop and could cause issues...
              if res.nil? || (res =~ denied) || (res =~ appraised && matched >= value) || res =~ high_value
                ELoot.msg("debug", 'unknown response from appraisal!') if res.nil?
                @sell_ignore.push(obj.id)
                ELoot.drag(obj, 'default')
                echo @sell_ignore
                next
              end
            end
          end

          # rubocop:disable Layout/LineLength
          item_sold = obj
          res = dothistimeout("sell ##{obj.id}", 3, item_selling_match) if !@sell_ignore.include?(obj.id)
          if res =~ denied || res =~ high_value
            @sell_ignore.push(obj.id)
          elsif res =~ sold
            sell_items.reject! { |obj| obj.id == item_sold.id }
          end
          Sell.stow_notes

          ELoot.drag(obj, 'default') if (GameObj.right_hand.id == obj.id) || (GameObj.left_hand.id == obj.id)
          # rubocop:enable Layout/LineLength
          # assume disk is no longer full
          @disk_full = false
        end

        #
        if gem_pouch_was_opened
          gemsack = ELoot.find_sack('gem')
          fput("close ##{gemsack.id}")
        end
      end

      ending_silver = ELoot.check_silver
      keep_silvers = ELoot.data.settings[:sell_keep_silver].to_i

      return unless ending_silver && ((keep_silvers.zero? || keep_silvers.nil?) || (ending_silver != keep_silvers))

      ELoot.go2('bank') if ELoot.check_silver > 0
      fput('share all') if ELoot.data.settings[:sell_share_silvers] && ending_silver > 1
      fput('deposit all') if Room.current.tags.include?('bank')
      fput("withdraw #{keep_silvers}") if keep_silvers.positive?
    end
  end
end

# Silence
silence_me if ELoot.data.settings[:silence]

# Initialize default settings
unless ELoot.data
  ELoot.load(ELoot.load_profile())
  sleep 0.5
end

# This may be OBE thanks to the default settings in load_profile
ELoot::Setup.new(ELoot.data.settings).start if ELoot.data.settings[:loot].empty?

# trying to add overflow concept - not the best place, but at least it registers
ELoot.data.sacks.store(ELoot.data.settings[:overflow_container].to_s, GameObj.inv.find { |i| i.name =~ /#{ELoot.data.settings[:overflow_container]}/ })
ELoot.data.sacks.delete("")
pp ELoot.data.sacks if ELoot.data.settings[:debug]

# Default to loot
if script.vars[1].nil?
  ELoot.loot
  exit
end

# This allows partial matches the same way Gemstone works.
# e.g., ;eloot sel would match ;eloot sell
command = '^box^help^setup^sell^load^list'

# No match - show help message
unless (index = (command =~ /\^#{script.vars[1]}/))
  ELoot.help
  exit
end

# Got a match, strip the command down to the parts in between the ^
start = index + 1
stop = command.index('^', index + 1) - 1

case command[start..stop]
when 'box'
  ELoot::Loot.box(GameObj.right_hand)
when 'help'
  ELoot.help
when 'list'
  ELoot::Setup.new(ELoot.data.settings).list if script.vars[2].nil?
  ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: script.vars[2]) if !script.vars[2].nil?
when 'sell'
  room = Room.current.id
  ELoot.sell
  ELoot.go2(room)
  fill_hands
when 'setup'
  ELoot::Setup.new(ELoot.data.settings).start
when 'load'
  ELoot.load(ELoot.load_profile)
  ELoot.data.sacks.store(ELoot.data.settings[:overflow_container].to_s, GameObj.inv.find { |i| i.name =~ /#{ELoot.data.settings[:overflow_container]}/ })
  ELoot.data.sacks.delete("")
end
