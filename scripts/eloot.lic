# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.
  Requires eloot.ui to be placed in your data folder

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributers: SpiffyJr, Athias, Demandred, Tysong, Deysh
              game: Gemstone
              tags: loot
           version: 1.3.0
  Improvements:
  
  v1.3.0
    - added exclusion functionality to looting and skinning
    - standardized chronoemage gold ring regex
    - refactored looting methods
  
  v1.2.8 (2022-04-21)
    - fix inventory containers regex with full hands
  
  v1.2.7 (2022-04-21)
    - added support to keep containers closed
    - removed redundant container looks
    - fixed invalid loot bug
    - reorganized yaml file save location
    - added versioning to UI and independant download
    - fixed duplicate 315 casting (maybe)
    - fixed excessive stancing when skinning
    - converted messaging to use built in Lich methods
    - fixed invalid_loot method
    - standardized empty/fill hands to use Lich methods
    - trash now looks for tag meta:trashcan first then falls back to old method
    - added additional check to fill hands after looting
    - initial inventory method changed to avoid using GameObj.inv
    - fixed stancing bug when frenzy is active
  
  v1.2.6 (2022-04-15)
    - support for weapon displayers
  
  v1.2.5 (2022-04-14)
    -fixed the fix for skinning (thanks Tysong)

  v1.2.4 (2022-04-14)
    - fixed searching while wounded bug
    - fixed missing skin weapon bug

  v1.2.3 (2022-04-12)
    - Correction to clothing looting
    - added debug toggle to help
    - fixed bug in container when looting
    - added spiked cavern urchin to the blunt skinning creatures
    - no need to ;eloot load after change in settings

  v1.2.2 (2022-04-08)
    - Typo in Loot.search method corrected

  v1.2.1 (2022-04-07)
    - Typo correction

  v1.2.0 (2022-04-07)
    - Support for scarab selling
    - Support for clothing looting / selling
    - Support for cursed looting / selling
    - Support for opening / closing containers during hunting
    - Fixes for phasing boxes and looting boxes
    
  v1.1.0 (2022-04-05)
    - Start option to just do locksmith pool added ;eloot pool 
    - toggle for disk usage
    - additional help comments
    - various creature loot support
    - toggle for looking inside boxes
    - bug fixes for box selling routine

  v1.0.0 (2022-04-03)
    - forked and renamed as eloot, rebasing version as v1.0.0
    - global rename from SLoot to ELoot
    - corrected ;eloot list to allow for parameters (loot, sell, skin, internal)
    - corrected for box and overflow constraint
    - added 'load' command back in - we found a point!
    - converted all CharSettings to yaml file to improve reliability
    - removed write-to-db3 capability - it is too inconsistent
    - improved bulk-gems logic (with thanks to Izzy101yzzI)
    - support for super secure gem pouches
    - default to silence output

  v2.2.1 (2021-12-23)
    - added any container specified in STOW LIST
    - added 'overflow' capabilities (although I still don't know why)
    - cleaned up bulk gem sales / individual gem sales logic
    - created a write-to-db3 capability rather than relying on lazy writes to db3
    - removed 'load' command - it is pointless

  v2.0.2 (2021-07-25)
    - Our chief edit is the loot. The loot and hands.
    - Our TWO chief edits are loot and hands. And gold rings.
    - Our THREE chief edits are loot, hands and gold rings. And many fixes to stuff and other stuff.
    - AMONG our edits are such diverse changes as loot fixes, items stowing and getting back out, hands, gold rings to chronomage, 604 support...oh nevermind I'll come back in.
    - Seriously though, lots of changes and fixes.
    - Zealot stance stuff removed?
    - Blunt skinning issues
    - More.

  v2.0.1 (2021-05-08)
    - Corrected skinning issue for left-handed skinners

  v2.0.0 (2021-04-12)
    - Rebaselined as SLoot 2.0
    - Fixed locksmith pool being full issue
    - Fixed container full issue when using disks (thanks to Demandred)
    - Added town locksmith processing
    - Added return to original location after ;sloot sell
    - Added expanded detail comment section and version
    - Added title bar update with version
    - Removed Hoarding option and related code
    - Updated internal comments
    - Updated to work with jinx data for sloot.ui

=end

# Check version of Lich for compatibility
LICH_GEM_REQUIRES = '5.4.1'
INFOMON_GEM_REQUIRES = '1.18.11'
INFOMON_VERSION = '0.0.0'
infomon_data = open("#{SCRIPT_DIR}/infomon.lic", 'r').read
if infomon_data =~ /^=begin\r?\n?(.+?)^=end/m
    comments = $1.split("\n")
else
    comments = []
    infomon_data.split("\n").each {|line|
        if line =~ /^[\t\s]*#/
            comments.push(line)
        elsif line !~ /^[\t\s]*$/
            break
        end
    }
end
for line in comments
    if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
        INFOMON_VERSION = $1.sub(/\s\(.*?\)/, '').strip
    end
end

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(LICH_GEM_REQUIRES) || Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(INFOMON_GEM_REQUIRES)
   if $frontend == 'stormfront' || $frontend == 'profanity'
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) & Infomon (#{INFOMON_GEM_REQUIRES}) to run." + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
     _respond ""
     _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Currently Running Infomon Version: #{Gem::Version.new(INFOMON_VERSION) }" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
   else
     _respond "##" + "########################################"
     _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) & Infomon (#{INFOMON_GEM_REQUIRES}) to run."
     _respond ">" + "Please update to a newer version."
     _respond ">" + ""
     _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }"
     _respond ">" + "Currently Running Infomon Version: #{Gem::Version.new(INFOMON_VERSION) }"
     _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
     _respond "##" + "########################################"
   end
   exit
end

ELoot_version = '1.3.0'
ELootUI_version = '1.1.0'

elootUI_VERSION = nil

if File.exist?("#{$data_dir}eloot.ui")

  File.foreach("#{$data_dir}eloot.ui") { |line| 
    if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
          elootUI_VERSION = $1.sub(/\s\(.*?\)/, '').strip
          break
    end
  }

  if elootUI_VERSION != ELootUI_version
    Lich::Messaging.msg(type = "warn", msg = " You're UI is an old version! ")
    Lich::Messaging.msg(type = "warn", msg = " Kill script if you don't want to download!")
    for i in (5).downto(1)
      Lich::Messaging.msg(type = "warn", msg = " Downloading in...#{i} ")
      sleep 1
    end
    
    Script.run("jinx", "data update eloot.ui --force")
  end
else
  Lich::Messaging.msg(type = "warn", msg = " You're UI is missing or its a first install. ")
  Lich::Messaging.msg(type = "warn", msg = " Kill script if you don't want to download!")
  for i in (5).downto(1)
      Lich::Messaging.msg(type = "warn", msg = " Downloading in...#{i} ")
      sleep 1
    end
    
    Script.run("jinx", "data install eloot.ui")
end

#move an existing profile from the old directory structure and save it to new one
old_dir = "#{$data_dir}eloot/#{XMLData.game}/"
new_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"

if (!File.exists? File.join(new_dir, "eloot.yaml")) && (File.exists? File.join(old_dir, "#{Char.name}.yaml"))
  Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
  Dir.mkdir("#{$data_dir}#{XMLData.game}/#{Char.name}") unless File.exist?("#{$data_dir}#{XMLData.game}/#{Char.name}")
 
  #Move the file
  FileUtils.cp("#{old_dir}#{Char.name}.yaml", new_dir)
 
  #Then rename it
  File.rename("#{new_dir}#{Char.name}.yaml", "#{new_dir}eloot.yaml")
 
  #Wait for it to finish
  sleep 0.5 until File.exists? File.join(new_dir, "eloot.yaml")
 
end
 
require 'yaml' #we clearly need to be saving information without CharSettings

# eloot is a looter for Gemstone that focuses on performance
module ELoot
  @@data ||= nil
  @sacks_to_close = []
  @sell_containers = []

  def self.load_defaults()
    
    default_hash = {
      :loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
      :loot_exclude=>["black ora", "urglaes"],
      :loot_phase=>false,
      :use_disk=>true,
      :loot_defensive=>false,
      :overflow_container=>"",
      :sell_loot_types=>["alchemy", "armor", "clothing", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "box"],
      :sell_exclude=>[],
      :sell_keep_scrolls=>[],
      :sell_appraise_types=>["jewelry", "magic", "uncommon", "valuable"],
      :sell_appraise_gemshop=>14999,
      :sell_appraise_pawnshop=>34999,
      :sell_collectibles=>true,
      :sell_gold_rings=>false,
      :sell_locksmith=>false,
      :sell_locksmith_pool=>true,
      :display_box_contents=>false,
      :sell_locksmith_pool_tip=>15,
      :sell_locksmith_pool_tip_percent=>true,
      :sell_share_silvers=>false,
      :sell_fwi=>false,
      :sell_keep_silver=>0,
      :skin_enable=>false,
      :skin_kneel=>false,
      :skin_604=>false,
      :skin_resolve=>false,
      :skin_sheath=>"",
      :skin_weapon=>"",
      :skin_weapon_blunt=>"",
      :silence=>true,
      :debug=>false,
      :unskinnable=>[],
      :keep_closed=>false
    }
    Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
    Dir.mkdir("#{$data_dir}#{XMLData.game}/#{Char.name}") unless File.exist?("#{$data_dir}#{XMLData.game}/#{Char.name}")

    File.write("#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml", default_hash.to_yaml)
   
    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{name}/eloot.yaml"
      if File.exist?("#{filename}") && name == Char.name
        settings_hash = YAML.load_file(filename)      
      elsif !File.exist?("#{filename}") && name != Char.name
        ELoot.msg("error", " ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?("#{filename}") && name == Char.name
        ELoot.msg("info", " No current settings found.  Loading defaults for configurtion.")
        ELoot.msg("info", " Suggest you configure to your needs with ;eloot setup")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg("error", " ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg("error", " ELoot.load_profile: name not defined")
    end
 
    settings_hash
    
  end

  def self.save_profile(name: Char.name)
    
    #This adds it to the profile for backward compatability
    ELoot.data.settings[:display_box_contents] = false unless ELoot.data.settings.has_key?(:display_box_contents)
    ELoot.data.settings[:use_disk] = true unless ELoot.data.settings.has_key?(:use_disk)
    ELoot.data.settings[:keep_closed] = true unless ELoot.data.settings.has_key?(:keep_closed)
    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml"
      if name == Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings saved to file: #{filename}.")
      elsif File.exist?("#{filename}") && name != Char.name
        ELoot.msg("info", " You are attempt to overwrite another profile!")
        ELoot.msg("info", " If you wish to overwrite, please ;unpause eloot.")
        ELoot.msg("info", " Else ;kill eloot and choose another filename.")
        pause_script
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings saved to file: #{filename}.")        
      elsif !File.exist?("#{filename}") && name != Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings are being saved to another profile!")
        ELoot.msg("info", " Settings saved to file: #{filename}.")
      else
        ELoot.msg("error", " ELoot.save_profile: There was an unknown error with saving a profile")
      end
    end
       
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.data
    @@data
  end

  def self.sell
    Sell.sell
  end

  def self.store_item(bag, item)
  
    Lich::Stash::try_or_fail(command: "_drag ##{item.id} ##{bag.id}") do
        20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and bag.contents.to_a.map(&:id).include?(item.id))
        sleep 0.1
      }
      return false
    end
  
  end

  def self.manage_sorter
  
    if running? "sorter"
      kill_script ("sorter")
      before_dying { Script.start('sorter') }
    end
   
  end

  def self.disk_usage
  
    return if DownstreamHook.list.include?("eloot-disk") && ELoot.data.settings[:use_disk]
  
    if ELoot.data.settings[:use_disk]
      15.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ })

        sleep(0.1)
      end
    
      DownstreamHook.add('eloot-disk',
        proc do |line|
          if line =~ /^Your <a exist="(\d+)" noun="(disk|coffin)">(disk|coffin)<\/a> arrives|^A small circular container suddenly appears/
            ELoot.data.disk_full = false if ELoot.data.disk.nil?
            ELoot.data.disk = GameObj.loot.find { |obj| obj.id == Regexp.last_match(1).to_s }
          end
          line
        end
      )
    else   
      ELoot.data.disk = nil
      DownstreamHook.remove("eloot-disk")
    end
    
  end

  def self.msg(type = info, text)
    #color options - set type to use
    #yellow, orange, teal, green, plain
    
    return if type == "debug" && !ELoot.data.settings[:debug]
       
    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end
    
    type = type == "debug" ? "speech" : type
    
    Lich::Messaging.msg(type, text)
  
  end

  def self.room_meta(key)
    key = "meta:#{key}"
    tag = Room.current.tags.find { |t| t =~ /#{key}/ }
    return Regexp.last_match(1).to_s if tag =~ /^#{key}:(.*)$/

    nil
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.wait_for_disk
 
    return unless ELoot.data.disk || !ELoot.data.settings[:use_disk]

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ }
      ELoot.msg("info", " Waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ })
        sleep(0.1)
      end
    end
 
    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    ELoot.check_sell_container(ELoot.data.disk) 

  end

  def self.change_stance(stance)
    return if Effects::Debuffs.active?("Frenzy") || dead?
    return if checkstance(stance.strip)
    return if stance == 'defensive' && checkstance('guarded')

    expiry = Time.now + 2
    while (cur_stance = checkstance) != stance
      res = dothistimeout("stance #{stance}", 2, /You are now|Roundtime|wait|Your rage causes you/i)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        expiry = Time.now + 2
      elsif Time.now > expiry
        break
      else
        break
      end
      sleep 0.5
    end
  end

  def self.drag(from, to)

    if from.class == GameObj && from.type =~ /box/ && to !~ /^(?:#{ELoot.data.disk}|hand)$/
      from = ELoot.phase_box(from) 
    end

    input_to_id = proc do |input|
      next input if %w[drop wear].include?(input)
      next "##{input.id}" if input.class == GameObj
      next GameObj.right_hand.id.nil? ? 'right' : 'left' if input == 'hand'

      if input.class == String
        next "##{input.to_i}" unless input.to_i.zero?
        sack = ELoot.data.sacks[input]        
        
        if sack.nil?
          ELoot.msg("info", " Failed to find sack for #{input}")
          sack = ELoot.data.sacks["default"]
        end
        next "##{sack.id}"
      end

      ELoot.msg("error", " Invalid param #{input.inspect} passed to drag")
    end

    ELoot.msg("debug", " Dragging #{from.inspect} to #{to.inspect}")

    to_id = input_to_id.call(to)
    from_id = input_to_id.call(from)

    if to_id.nil? || from_id.nil?
      ELoot.msg("error", " There was an issue dragging #{from_id} to #{to_id}")
      return
    end

    ELoot.msg("debug", " #{from_id.inspect} to #{to_id.inspect}")
   
    waitrt?
   
    lines = ELoot.silent_command("_drag #{from_id} #{to_id}", /You|Spreading your wings|Draping the|Heedful of your surroundings/, true)

    # was it closed?
    if lines.any? { |l| l =~ /It's closed|That is closed/i } && from.type !~ /box/
      fput("open #{to_id}")
      drag(from, to)
    elsif lines.any? { |l| l =~ /There appears to be an/i }
      ELoot.msg("info", " Possibly an item you want to keep")
      ELoot.msg("info", " Sleeping for 10 seconds: ;kill the script to hold onto it")
      sleep(10)
      drag(from, to)
    elsif lines.any? { |l| l =~ /won't fit in the/ }
      ELoot.data.disk_full = true if to == ELoot.data.disk
      if to_id != "#" + ELoot.data.sacks["default"].id
        ELoot.msg("info", " The #{from} won't fit in the #{to}. Trying default container.")
        drag(from, "default")
      elsif ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", " You have not set an OVERFLOW container.")
        ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop #{from_id}")
      else
        ELoot.msg("info", " Your STOW container is full. Attempting to store in overflow.")
        overflow_attempted = ELoot.data.sacks[ELoot.data.settings[:overflow_container]]
        res = fput("_drag #{from_id} ##{overflow_attempted.id}")
        if res =~ /won't fit in the/
          ELoot.msg("info", " Your OVERFLOW container cannot hold this item.")
          ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
          sleep(3)
          fput("drop #{from_id}")
        end
      end
    elsif lines.any? { |l| l =~ /You need a free hand to pick that up/ }
      ELoot.msg("error", " This shouldn't happen. Something is wrong")
      ELoot.msg("error", " Please give this information to the EoL team to look into.")
      ELoot.msg("error", "---------- Start of Error Data -------------")
      fput "look"
      ELoot.msg("error", " GameObj.right_hand.inspect: #{GameObj.right_hand.inspect}")
      ELoot.msg("error", " GameObj.left_hand.inspect: #{GameObj.left_hand.inspect}")
      ELoot.msg("error", " from: #{from} to: #{to}")
      ELoot.msg("error", *ELoot.data.sacks)
      ELoot.msg("error", *ELoot.data.settings)
      ELoot.msg("error", "---------- End of Error Data -------------")
      exit
      
    end
    
  end

  def self.find_skinner(type)
    case type
    when :normal
      weapon_name = ELoot.data.settings[:skin_weapon]
    when :blunt
      weapon_name = ELoot.data.settings[:skin_weapon_blunt]
    end

    return nil if weapon_name.empty?
    return ELoot.data.skinners[type] if ELoot.data.skinners[type]

    unless ELoot.data.skinsheath
      unless ELoot.data.settings[:skin_sheath].empty?
        ELoot.data.skinsheath = GameObj.inv.find do |i|
          i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/ ||
            i.noun =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/
        end
      end

      ELoot.data.skinsheath ||= ELoot.data.sacks["default"] 
    end

    ELoot.check_sell_container(ELoot.data.skinsheath)
    
    items = ELoot.data.skinsheath.contents.clone
    items.push(GameObj.right_hand)
    items.push(GameObj.left_hand)

    weapon = items.find do |c|
      next if c.nil? || c.id.nil?
      c.name =~ /#{weapon_name}/i || c.noun =~ /\b#{weapon_name}\b/i
    end

    #we either lost it or its on one of those weapon displayers
    unless weapon
      inventory = []
      exist =  %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}
   
      lines = ELoot.silent_command("inventory full",/You are currently wearing/)
      
      lines.each do |line|
        line.scan(exist).each do |matches| inventory << GameObj.new(*matches) end
      end
  
      weapon = inventory.find { |i| i.name =~ /#{weapon_name}/ }
       
    end

    unless weapon
      ELoot.msg("info", " Failed to find skinner: #{weapon_name} in #{ELoot.data.skinsheath}")
      return nil
    end

    ELoot.data.skinners[type] = weapon
    ELoot.data.skinners[type]
  end

  def self.find_trash
  
    can = $1 if Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/}
      
    unless can
      can = ["crate", "barrel", "wastebarrel", "wastebasket", "casket", "canister"]
    end
     
    trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find_all { |obj| (obj.name =~ Regexp.union(can) && obj.name !~ /\w+'s #{obj.noun}$/) && obj.type !~ /box/}.last 
       
  end

  def self.silent_command(command, start_pattern, loud = false, end_pattern = /<prompt/, include_end = false, timeout=5)
      result = []
      name = "Sell:: -#{Time.now.tv_sec}.#{Time.now.tv_usec}-#{Random.rand(10000)}"
      filter = false
      save_want_downstream = Script.current.want_downstream
      save_want_downstream_xml = Script.current.want_downstream_xml
      Script.current.want_downstream = false
      Script.current.want_downstream_xml = true

      begin
        Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc { |xml|
            is_loud = loud ? xml : nil
            if filter
              if xml =~ end_pattern
                DownstreamHook.remove(name)
                filter = false
              else
                next(is_loud)
              end
            elsif xml =~ start_pattern
              filter = true
              next(is_loud)
            else
              xml
            end
          })
          $_SERVER_.puts command
          until (xml = get) =~ start_pattern; end
          result << xml.rstrip
          until (xml = get) =~ end_pattern
            result << xml.rstrip
          end
          if include_end
            result << xml.rstrip
          end
        }
      rescue Interrupt
        nil
      ensure
        DownstreamHook.remove(name)
        Script.current.want_downstream_xml = save_want_downstream_xml
        Script.current.want_downstream = save_want_downstream
      end
         
      return result
    end
 
  def self.open_loot_containers(item)
    #Method intended for opening containers that will receive loot from the loot room or loot item command

    return unless ELoot.data.settings[:keep_closed]
  
    ELoot.open_single_container(ELoot.data.sacks["default"])
    ELoot.open_single_container(ELoot.data.settings[:overflow_container])
    
    #item = item == "room" ? GameObj.loot : item.contents
    containers = Array.new 
    item.each{ |loot|
      next if ELoot.data.sacks[loot.type].nil?
      unless containers.include?(ELoot.data.sacks[loot.type].id)
        ELoot.open_single_container(ELoot.data.sacks[loot.type])
        containers.push(ELoot.data.sacks[loot.type].id)
      end    
    }
     
  end
  
  def self.open_single_container(sack)
 
    container = sack.class == GameObj ? sack : ELoot.data.sacks[sack]
    
    lines = ELoot.silent_command("open ##{container.id}",ELoot.data.silent_open) 
    if lines.any?{ |line| line =~ ELoot.data.needs_closed }
      @sell_containers.push(container) unless @sell_containers.include?(container)
    end  
   
  end
  
  def self.check_sell_container(sack)
 
    ELoot.msg("debug", "ELoot.check_sell_container: sack = #{sack}")
 
    return if sack == nil || sack == ""
   
    container = sack.class == GameObj ? sack : ELoot.data.sacks[sack]
   
    #take a look to refresh contents and see if closed
    lines = ELoot.silent_command("look in ##{container.id}",ELoot.data.look_regex)
        
    ELoot.msg("debug", "ELoot.check_sell_container: lines = #{lines}")
    
    #if closed lets open it up
    if lines.any?{ |line| line =~ /That is closed|is shut too tightly to see its contents/i }
      #open the bag
      ELoot.msg("debug", "ELoot.check_sell_container: opening bag")
      ELoot.silent_command("open ##{container.id}",ELoot.data.silent_open)
      
      #check out whats inside
      ELoot.silent_command("look in ##{container.id}",ELoot.data.look_regex)
    
      #we had to open it so lets remember that
      @sell_containers.push(container) unless @sell_containers.include?(container) 
    end
  
  end
  
  def self.close_sell_containers
    
    return unless ELoot.data.settings[:keep_closed]
  
    @sell_containers.each{ |sack|
      ELoot.close_container(sack)
    } 
  end
  
  def self.close_container(bag)
     
    close_regex = /You close .*|That is already closed|What were you referring to|seem to be any way to do that|You tie|Discreetly slipping your hand|You wrap/  
    ELoot.silent_command("close ##{bag.id}",close_regex)
     
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg("info", " Your current status prevents you from looting.")
      return
    end

    @right_hand = GameObj.right_hand
    @left_hand = GameObj.left_hand

    ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    ELoot.msg("debug", "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg("debug", "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg("debug", "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg("debug", "ELoot.loot: Looting the Room")
    Loot.room
  
    ELoot.recover_right
    ELoot.recover_left
 
  end

  def self.help
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", " ELoot by SpiffyJr, maintained by Elanthia-Online")
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", " ELoot is a looter script designed to make looting as fast and easy as possible.")
    ELoot.msg("yellow", " Commands to get latest version:")
    ELoot.msg("yellow", " #{$lich_char}jinx data install eloot.ui")   
    ELoot.msg("yellow", " #{$lich_char}repo download eloot")  
    ELoot.msg("yellow", " Both files may be needed for updates.")   
    ELoot.msg("yellow", "")
    ELoot.msg("teal",   " Basic usage: #{$lich_char}eloot")
    ELoot.msg("yellow", "")
    ELoot.msg("green",  " Extra commands:")
    ELoot.msg("teal",   "  help        shows this help message")
    ELoot.msg("teal",   "  box         loots a box in your hand")
    ELoot.msg("teal",   "  list           lists current settings")
    ELoot.msg("teal",   "  sell          sells your loot sacks")
    ELoot.msg("teal",   "  pool        does just the locksmith pool")
    ELoot.msg("teal",   "  --debug=on/off        toggles debug messages")
    ELoot.msg("yellow", "")
    ELoot.msg("green", "  Warning     *** Mark ANYTHING you don't want to lose. ELoot is not perfect! ***")
    ELoot.msg("yellow", "")
  end

  def self.go2(place)
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.class == String && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      if ELoot.data.settings[:debug]
        ELoot.msg "info", "unknown room location: hope you know what you're doing"
      else
        ELoot.msg "error", 'unknown room location'
      end
    end
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def self.withdraw_silver(amount)
    return if amount <= 0

    ELoot.go2('bank')

    # TODO: handle not enough silver case
    fput("withdraw #{amount} silvers")
  end

  def self.check_silver
    silvers = 0
		lines = silent_command(
			"info",
			/Name: <a exist=.*? noun/					
		)
	
		lines.each do |line|
			next unless line =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9,]+)/				
			silvers = $1.delete(",").to_i
		end
			
		return silvers
  end

  def self.deposit_silver
  
    ending_silver = ELoot.check_silver
    keep_silvers = ELoot.data.settings[:sell_keep_silver].to_i  
    note = ELoot.data.sacks["default"].contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }

    return unless keep_silvers.positive? || ending_silver > 0 || note
    
    ELoot.go2('bank') 
    fput('share all') if ELoot.data.settings[:sell_share_silvers] && ending_silver > 1
    fput('deposit all') if ending_silver > 0 || note 
    fput("withdraw #{keep_silvers}") if keep_silvers.positive?
   
  end
 
  def self.recover_right
  
    #ID's match - nothing to do.
    return if GameObj.right_hand.id == @right_hand.id 
 
    waitrt?
 
    #Maybe it's in the left hand
    if GameObj.left_hand.id == @right_hand.id 
      dothistimeout('swap', 3, /You swap/i)
      
      #Did that fix it?
      return if GameObj.right_hand.id == @right_hand.id      
    end
    
    #Still here so lets get the right hand empty - Don't toss a weapon/shield!
    if !GameObj.right_hand.id.nil?
      ELoot.drag(GameObj.right_hand, "default")
      ELoot.drag(@right_hand, "hand")
    end
   
    #Now are we correct?
    return if GameObj.right_hand.id == @right_hand.id
    
    #All out of options - Notify and bail
    if GameObj.right_hand.id != @right_hand.id
      ELoot.msg(type = "orange", " Can't seem to refill your right hand!")
      ELoot.msg(type = "orange", " This shouldn't happen! Please grab a log and let the EOL team know.")
      return 
    end
  end

  def self.recover_left
  
    #ID's match - nothing to do.
    return if GameObj.left_hand.id == @left_hand.id 
    
    waitrt?
    
    #Maybe it's in the right hand
    if GameObj.right_hand.id == @left_hand.id 
      fput "swap"
      
      #Did that fix it?
      return if GameObj.left_hand.id == @left_hand.id      
    end
    
       
    #Still here so lets get the left hand empty - Don't toss a weapon/shield!
    if !GameObj.left_hand.id.nil? 
      ELoot.drag(GameObj.left_hand, "default")
      ELoot.drag(@left_hand, "hand")
    end
    
    #Now are we correct?
    return if GameObj.left_hand.id == @left_hand.id
    
    #All out of options - Notify and bail
    if GameObj.left_hand.id != @left_hand.id
      ELoot.msg(type = "orange", " Can't seem to refill your left hand!")
      ELoot.msg(type = "orange", " This shouldn't happen! Please grab a log and let the EOL team know.")
      return 
    end
  end

  def self.find_boxes 
  
    ELoot.wait_for_disk
    ELoot.msg("debug", "find_boxes: ELoot.data.disk is #{ELoot.data.disk}")
    if ELoot.data.disk && ELoot.data.settings[:use_disk]
      disk_contents = ELoot.data.disk.contents.to_a
      ELoot.msg("debug", "find_boxes: disk_contents found")
    else
      disk_contents = []
      ELoot.msg("debug", "find_boxes: disk_contents empty")
    end
      
    box_sacks = [ELoot.data.sacks["default"], ELoot.data.sacks["box"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]      
    box_sacks.each{ |sack|
      next if sack.nil? 
      ELoot.open_single_container(sack) 
    }   

    default_contents = ELoot.data.sacks["default"].contents.to_a
    overflow_box_contents = ELoot.data.sacks[ELoot.data.settings[:overflow_container]].contents.to_a
    box_contents = ELoot.data.sacks["box"].contents.to_a
       
    box_list = (default_contents + box_contents + disk_contents + overflow_box_contents).find_all { |obj| obj.type =~ /box/ }.uniq
 
    box_list.dup.each{|box|
      lines = ELoot.silent_command("look in ##{box.id}",/There is nothing|In the(.*?)#{box.noun}|That is closed|You see the shifting form/)
      box_list.delete(box) if lines.any?{ |line| line =~ /There is nothing|In the/i }
    }

    box_list


  end

  def self.phase_box(box)
    return box unless ELoot.data.settings[:loot_phase] && Spell[704].known? && Spell[704].affordable? && box.name !~ /enruned|mithril/i 

    waitrt?

    lines = ELoot.silent_command("look in ##{box.id}",/There is nothing|In the(.*?)#{box.noun}|That is closed|You see the shifting form/)
    return box unless lines.any?{ |line| line =~ /That is closed/i }
  
    if !checkright.nil? && !checkleft.nil? && ![GameObj.left_hand.id, GameObj.right_hand.id].include?(box.id)
      empty_hand
    end

    ELoot.drag(box, 'hand') unless [GameObj.left_hand.id, GameObj.right_hand.id].include?(box.id)
  
    Spell[704].cast("at ##{box.id}")
 
    return GameObj.right_hand if GameObj.right_hand.type =~ /box/
    return GameObj.left_hand if GameObj.left_hand.type =~ /box/
     
  end

  def self.unphase_box(box)
  
    lines = ELoot.silent_command("look at ##{box.id}",/You see/)
    return box unless lines.any?{ |line| line =~ /shifting/i }
  
    dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    sleep 0.5
 
    lines = ELoot.silent_command("glance hands",/You glance down/)
 
    return GameObj.right_hand if GameObj.right_hand.type =~ /box/  
    return GameObj.left_hand if GameObj.left_hand.type =~ /box/
    
  end

  def self.decurse(obj)
  
    return true unless obj.type =~ /cursed/

    if !Spell[315].known?
      ELoot.msg("info", "** #{obj.name} is cursed. And you don't know cleric spell 315. Can't touch that.")
      return false
    elsif Spell[315].known? && !Spell[315].affordable?
      ELoot.msg("info", "** #{obj.name} is cursed and you don't have emough mana to cast 315.")
      return false
    elsif  !ELoot.data.settings[:loot_types].include?("cursed")
      ELoot.msg("info", "** #{obj.name} is cursed and you don't have the setting enabled for looting it.")
      return false
    elsif Spell[315].known? && Spell[315].affordable?
      #Fixme: add hinderance check
      Spell[315].cast("at ##{obj.id}")
      return true
    end
  
  end

  # Global data used by ELoot
  class Data
    attr_accessor :disk, :disk_full, :stored, :ready_list, :sacks, :settings, :skinners, :skinsheath, :silent_open, 
                  :needs_closed, :look_regex, :sacks_closed, :all_loot_categories, :regex_gold_rings

    def initialize(settings)
      @disk = nil
      @disk_full = false
      @ready_list = {}
      @sacks = {}
      @settings = settings
      @skinners = {}
      @skinsheath = nil
      @stored = []
      @sacks_closed = Array.new

      $sell_ignore = Array.new

      @look_regex = Regexp.union(
        /Peering into the <a exist=.*? noun="toolkit">/i,
        /That is closed/i,
        /is shut too tightly to see its contents/i,
        /In the(.*?)you see/i,
        /In the(.*?):/i,
        /There is nothing/i,
        /You glance/i,
        /^Attached to a.*keyring/i,
        /.*?[.*?]:/i,
      )
      @silent_open = Regexp.union(
        /You throw back/i,
        /You open/i,
        /You pick at the knot/i,
        /is already open/i,
        /is open already/i,
        /You unfasten/i,
        /^What were you referring to\?/i,
        /^I could not find what you were referring to\./i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
      )
      @needs_closed = Regexp.union(
        /You throw back/i,
        /You open/i,
        /You pick at the knot/i,
        /You unfasten/i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
      )
          
      @regex_gold_rings = /^(dingy|plain|braided|twisted|intricate|large|thin|wide|polished|scratched|thick|dull|faded|small|flawless|inlaid|dirt\-caked|ornate|exquisite|shiny|bright|narrow) gold ring$|^gold ring$/
      
      @all_loot_categories = ["alchemy", "armor", "box", "clothing", "collectible", "cursed", "gem", "herb", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "weapon"]
      
      ready_list_match = /(?:shield|weapon):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="\d+"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>/    
      ready_lines = ELoot.silent_command("ready list",/Your current settings are/)		  
        
      ready_lines.each {|line|
        if line =~ ready_list_match
          @ready_list.store(Regexp.last_match(1).to_s.downcase, Regexp.last_match(2).to_s.downcase)
        end
      }
      
      items = []
      exist =  %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}
      
      lines = ELoot.silent_command("inventory containers", /You are (?:holding|wearing)/)
      
      lines.each do |line| line.scan(exist).each do |matches| items << GameObj.new(*matches) end end
      
      container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
      container_lines = ELoot.silent_command("stow list",/You have the following/)		  
        
      container_lines.each {|line|   
        if line =~ container_match
          @sacks.store(Regexp.last_match(2), items.find { |i| i.id == Regexp.last_match(1) })
          @sacks.delete(Regexp.last_match(2)) unless @sacks[Regexp.last_match(2)]    
        end
      }
                
      #Add the overflow sack 
      @sacks.store(@settings[:overflow_container].to_s, items.find { |i| i.name =~ /#{@settings[:overflow_container]}/ })
      @sacks.delete("")

      if @sacks['default'].nil?
        ELoot.msg("error", " Set stow container using STOW SET before using this script") 
        exit
      end
  
      if @settings[:debug]
        Lich::Messaging.msg("speech", "ready list: #{@ready_list.inspect}")
        Lich::Messaging.msg("speech", "sacks: #{@sacks.inspect}")
      end
          
    end
  end

  # Setup is an extension of Gtk::Builder for Gtk setup
  class Setup < Gtk::Builder
    
    @@categories = {
      loot: {
        loot_types: {
        #:loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        loot_exclude: {
        #:loot_exclude=>["black ora", "urglaes"],
          default: ["black ora", "urglaes"],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        critter_exclude: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        loot_phase: { default: false },
        #:loot_phase=>false,
        use_disk: { default: true },
        loot_defensive: { default: false },
        #:loot_defensive=>false,
        overflow_container: { default: '' },
        keep_closed: { default: false }
        #:overflow_container=>"",
      },
      sell: {
        sell_loot_types: {
        #:sell_loot_types=>["alchemy", "armor", "clothing", "gem", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        sell_exclude: {
        #:sell_exclude=>[],
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        sell_keep_scrolls: {
        #:sell_keep_scrolls=>[],
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = Spell[text].num
              iter[1] = Spell[text].name
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(Spell[selected.get_value(0)].num)
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)
            next if Spell[text].nil?

            setting.push(Spell[text].num)
            setting.uniq!.sort!
          end
        },
        sell_appraise_types: {default: ["jewelry", "magic", "uncommon", "valuable"]},
        sell_appraise_gemshop: { default: 14_999 },
        sell_appraise_pawnshop: { default: 34_999 },
        sell_collectibles: { default: true },
        sell_gold_rings: { default: false },
        sell_locksmith: { default: false },
        sell_locksmith_pool: { default: true },
        display_box_contents: { default: false },
        sell_locksmith_pool_tip: { default: 15 },
        sell_locksmith_pool_tip_percent: { default: true },
        sell_share_silvers: { default: false },
        sell_fwi: { default: false },
        sell_keep_silver: { default: 0 }
      },
      skin: {
        skin_enable: { default: false },
        skin_kneel: { default: false },
        skin_604: { default: false },
        skin_resolve: { default: false },
        skin_sheath: { default: '' },
        skin_weapon: { default: '' },
        skin_weapon_blunt: { default: '' },
        skin_exclude: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
      },
      internal: {
        silence: { default: true },
        debug: { default: false },
        unskinnable: { default: [] }
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()

      @settings = settings

      # set default values if they don't exist
      @@categories.each do |_, data|
    
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

      # only sorcerers can phase
      @settings[:loot_phase] = false unless Char.prof == 'Sorcerer'

      # 604 support
      @settings[:skin_604] = false unless Spell[604].known?

      # GoS only for Sigil of Resolve
      @settings[:skin_resolve] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 4

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        add_from_file("#{$data_dir}eloot.ui")
        load_settings

        self['main'].keep_above = true
        self['main'].set_title "ELoot Setup v#{ELoot_version}"

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update

          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        end
      end
    end

    def on_close_clicked
      ELoot.save_profile()
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue { @running = false }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_resolve")) && !Spell[9704].known?
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_604")) && !Spell[604].known?
          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          next if Setup.get_setting(key).nil?

          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true

      Gtk.queue { self['main'].show_all }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      ELoot.msg("error", "** Setting \"#{key}\" does not exist") if setting.nil?

      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        ELoot.msg("info", " Reset #{key}")
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          ELoot.msg("info", " \"#{value}\" removed from \"#{key}\"")
        else
          @settings[key].push(value)
          ELoot.msg("info", " \"#{value}\" added to \"#{key}\"")
        end

        ELoot.msg("info", " \"#{key}\" is now \"#{@settings[key].join(', ')}\"")
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        ELoot.msg("info", " \"#{key}\" has been set to \"#{value}\"")
        @settings[key] = value
      end
    end
  end

  # Loot handles the room looting for ELoot
  module Loot
  
    def self.single_drag(item) #drags single item into container
      #Using built in lich command
      
      if item.type =~ /box/      
        item = ELoot.phase_box(item) 
        
        if ELoot.data.disk && !ELoot.data.disk_full && ELoot.data.settings[:use_disk]
          #Wait for disk to arrive
          ELoot.wait_for_disk
          if ELoot.data.disk
            result = ELoot.store_item(ELoot.data.disk, item)
            return if result
            #inform user it didn't fit if !result
            ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.disk}. Trying different container.")
            ELoot.data.disk_full = true
          end              
        end
      end
             
      #If we are still here lets see if a sack type was identified
      if ELoot.data.sacks[item.type]
        result = ELoot.store_item(ELoot.data.sacks[item.type], item)
        return if result
        
        #inform user it didn't fit
        ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks[item.type]}. Trying default container.")     
      end
      
      #Still here? Try the default
      result = ELoot.store_item(ELoot.data.sacks["default"], item)
      return if result
      
      #inform user it didn't fit
      ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks["default"]}. Trying overflow container.")
      
      #try the overflow
      if ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", " You have not set an OVERFLOW container.")
        ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop ##{item.id}")
      else
        result = ELoot.store_item(ELoot.data.sacks[ELoot.data.settings[:overflow_container]], item)
        return if result      
        ELoot.msg("info", " Your OVERFLOW container cannot hold this item.")
        ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop ##{item.id}")
      end
            
    end
 
    def self.single_loot(item) #loots a single item
        
      begin
        Lich::Stash::try_or_fail(command: "loot ##{item.id}") do
          20.times {
            return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks[item.type].contents.to_a.map(&:id).include?(item.id))
            return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks["default"].contents.to_a.map(&:id).include?(item.id))
            sleep 0.1
          }
        end
      rescue => exception
        echo "self.single_loot(item) had an error"
        echo "obj: #{item} type: #{item.type}"
        echo "GameObj.right_hand.inspect #{GameObj.right_hand.inspect}"
        echo "GameObj.left_hand.inspect #{GameObj.left_hand.inspect}"
        echo exception.backtrace
              
        #Loot failed - just drag it
        Loot.single_drag(item)
        
        return
      end
      
         
      #inform user it didn't fit
      ELoot.msg("info", " The #{item} wasn't looted. Trying overflow container.")
      
      #still here so try overflow
      if ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", " You have not set an OVERFLOW container.")
        ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop ##{item.id}")
      else
        result = ELoot.store_item(ELoot.data.sacks[ELoot.data.settings[:overflow_container]], item)
        return if result      
        ELoot.msg("info", " Your OVERFLOW container cannot hold this item.")
        ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
        sleep(3)
        fput("drop ##{item.id}")
      end
 
    end
 
    def self.box_loot(box) #Loots box contents
        
      res = dothistimeout("open ##{box.id}", 3, /open|locked/)      
      return Loot.single_drag(box) if res =~ /locked/
  
      if ELoot.data.settings[:display_box_contents]
        fput "look in ##{box.id}" 
      else
        ELoot.silent_command("look in ##{box.id}",/There is nothing|In the|That is closed/)
      end
  
      if box.contents.empty?
        ELoot.msg("info", " Failed to see contents of #{box.name}. ")
        Loot.single_drag(box)
        return
      end

      if box.contents.any? { |obj| obj.name =~ /silver coins/ }
        res = dothistimeout("get coins from ##{box.id}", 3, /You gather the remaining|Get what\?/)
        ELoot.msg("info", " Unknown get coin result") if res !~ /You gather the remaining/
        sleep 0.5
        waitrt?
      end

      objs = Loot.reject_invalid_loot(box.contents)
      if objs.empty?     
        Sell.save_trash_box(box)
        return 
      end
      #Open sacks for looting the room
      ELoot.open_loot_containers(objs)
      
      #If handled, we reject them since they're already looted.
      types = ["box", "clothing", "collectible", "cursed", "jewelry"]
      objs = objs.reject do |thing|
        next false if ELoot.data.settings[:loot_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:loot_exclude])     
        unless thing.type =~ Regexp.union(ELoot.data.settings[:loot_types].reject { |x| !types.include?(x)}) \
          || (thing.type =~ /weapon/i && thing.type =~ /uncommon/ ) && ELoot.data.settings[:loot_types].include?("weapon") \
          || (thing.type =~ /armor/i && thing.type =~ /uncommon/ ) && ELoot.data.settings[:loot_types].include?("armor") 
          next false       
        end
     
        Loot.single_drag(thing)
        next true
      end
      ELoot.msg("debug", " Loot.box_loot: After specials check")
      
      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      if objs.empty?     
        Sell.save_trash_box(box)
        return 
      end
      
      # Find out what loot is valid so we can match it to the remaining loot
      valid = Loot.valid_objs(objs.clone) if not objs.empty?
      invalid = Loot.invalid_objs(objs.clone) if not objs.empty?
      ELoot.msg("debug", " Loot.box_loot - valid: #{valid}")
      ELoot.msg("debug", " Loot.box_loot - invalid: #{invalid}")

      # Is there anything else we care about?
      if valid.empty? && !invalid.empty?    
        invalids = []
        invalid.each{ |t| invalids.push(t.name) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.")      
      elsif invalid.empty? && !valid.empty?
        ELoot.msg("debug", " Loot.box_loot: looting box")
        res = dothistimeout("loot ##{box.id}", 3, /You search through/)
        ELoot.msg("info", " Failed to LOOT box") if res.nil?
        sleep(0.10)

        if box.contents.length.positive?
          lootsack = ELoot.data.sacks['default']
          res = dothistimeout("empty ##{box.id} in ##{lootsack.id}", 3, /You try to empty/)
          sleep 0.5
          waitrt?
          if res.nil?
            ELoot.msg("info", " Failed to EMPTY box")          
            ELoot.msg("info", " Sleeping for 3 seconds: ;kill the script to handle yourself")
            fput "look in ##{box.id}"            
            sleep 3
          end
        end      
      else
        valid.each do |thing|
          Loot.single_drag(thing)
        end
        invalids = []
        invalid.each{ |t| invalids.push(t.name) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.") if invalid.length.positive?
      end
      
      Sell.save_trash_box(box)
      
    end
 
    def self.loot_all(items) #loots entire room #Fixme
  
      res = dothistimeout('loot room', 3, /With a discerning eye|There is no loot|(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/)
    
      #Didn't get it all?...something in-hand?
      if res =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/
        
        Loot.single_drag(GameObj.right_hand) if items.include?(GameObj.right_hand)
        Loot.single_drag(GameObj.left_hand) if items.include?(GameObj.left_hand)  
        
        #Anything left?
        objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
        return if objs.empty?
        
        #Still here so rerun Loot.room
        Loot.room
        
      end
    end
 
    def self.reject_invalid_loot(objs) #rejects items from the GamObj.loot object
      objs.reject do |obj|
        obj.name =~ /\bsevered\b/i ||
        obj.id.to_i.negative? ||
        (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon/i) ||
        obj.name =~ /#{Char.name} (?:disk|coffin)$/ ||
        obj.name == "corroded bronze scaling fork"
           
      end
    end

    def self.valid_objs(objs) #finds valid loot
      if !ELoot.data.settings[:loot_types].nil?
        objs.reject do |obj|
          obj.type !~ Regexp.union(ELoot.data.settings[:loot_types]) ||
            (ELoot.data.settings[:loot_exclude].length.positive? &&
             obj.name =~ Regexp.union(ELoot.data.settings[:loot_exclude]))
        end
      end
    end

    def self.invalid_objs(objs) #finds non-valid loot
      
      begin
        invalid_categories = ELoot.data.all_loot_categories - ELoot.data.settings[:loot_types]
        objs.find_all do |obj|
          next if obj.nil?
          obj.type =~ Regexp.union(invalid_categories)  \
          || (ELoot.data.settings[:loot_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:loot_exclude]))          
        end
      rescue => exception
        echo "self.invalid_objs(objs) had an error"
        echo "obj: #{obj} type: #{obj.type}"
        echo "GameObj.right_hand.inspect #{GameObj.right_hand.inspect}"
        echo "GameObj.left_hand.inspect #{GameObj.left_hand.inspect}"
        echo "invalid_categories: #{invalid_categories}"
        echo "ELoot.data.all_loot_categories: #{ELoot.data.all_loot_categories}"
        echo "ELoot.data.settings[:loot_types]: #{ELoot.data.settings[:loot_types]}"
        echo "objs: #{objs}"
        echo exception.backtrace
        raise 
      end
  
    end
    
    def self.room #method that loots the room
      
      objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
      return if objs.empty?
      
      #if we are still here lets empty a hand
      if !checkright.nil? && !checkleft.nil?
        empty_hand
      end 
      
      #Open sacks for looting the room
      ELoot.open_loot_containers(objs)
 
      # Boxes go first. If handled, we reject them since they're already looted.
      types = ["box", "clothing", "collectible", "cursed", "jewelry"]
      objs = objs.reject do |thing|
        next false if ELoot.data.settings[:loot_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:loot_exclude])     
        unless thing.type =~ Regexp.union(ELoot.data.settings[:loot_types].reject { |x| !types.include?(x)}) \
          || (thing.type =~ /weapon/i && thing.type =~ /uncommon/ ) && ELoot.data.settings[:loot_types].include?("weapon") \
          || (thing.type =~ /armor/i && thing.type =~ /uncommon/ ) && ELoot.data.settings[:loot_types].include?("armor") 
          next false       
        end
     
        Loot.single_drag(thing) if ELoot.decurse(thing)
        next true
      end
      ELoot.msg("debug", " Loot.room: After specials check")
      
      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      return if objs.empty?
      
      # Find out what loot is valid so we can match it to the remaining room loot
      valid = Loot.valid_objs(objs.clone) if not objs.empty?
      invalid = Loot.invalid_objs(objs.clone) if not objs.empty?
      ELoot.msg("debug", " Loot.room - valid: #{valid}")
      ELoot.msg("debug", " Loot.room - invalid: #{invalid}")

      # Is there anything else we care about?
      if valid.empty? && !invalid.empty?    
        invalids = []
        invalid.each{ |t| invalids.push(t.name) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.")      
      elsif invalid.empty? && !valid.empty?
        ELoot.msg("debug", " Loot.room: Calling Loot.loot_all")
        Loot.loot_all(valid)
      else
        valid.each do |obj|
          if obj.type !~ /clothing|jewelry|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic|collectible/
            Loot.single_drag(obj)
          else
            Loot.single_loot(obj)
          end
        end
        invalids = []
        invalid.each{ |t| invalids.push(t.name) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.") if invalid.length.positive?
      end
                
      fill_hand if @normal_fill_hand
      fill_hands if @blunt_fill_hands
      fill_right_hand if @blunt_fill_right_hand
      fill_left_hand if @blunt_fill_left_hand
      
      fill_hand
      
      ELoot.msg("debug", " Loot.room: End of method")
      
    end

    def self.search(objs = GameObj.dead.to_a) #searches dead critters
      return if objs.empty?

      search_refill_hand = false

      inhand_critters = /skayl|glacei|tumbleweed|plant|shrub|creeper|vine|bush/

      if objs.any? { |o| o.name =~ inhand_critters } #&& (ELoot.data.settings[:loot_exclude].length.positive? && objs.name !~ Regexp.union(ELoot.data.settings[:loot_exclude]))#Fixme: excluded critter check here
        if !checkright.nil? && !checkleft.nil?
          empty_hand
          search_refill_hand = true
        end
      end

      objs.each do |thing|
        return if (ELoot.data.settings[:critter_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:critter_exclude]))
        #Fixme: excluded critter check here
        ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]

        # Loot it
        3.times do
          waitrt?
          res = dothistimeout("loot ##{thing.id}", 1, /You search|not in any condition/)
          break if res =~ /You search|not in any condition/ || thing.status =~ /gone/ || thing.nil?
        end

        # Some creatures put an item directly in your hand
        if thing.name =~ inhand_critters
          item = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.type == "gem"}
          if item 
            container = ELoot.data.sacks[item.type].nil? ? ELoot.data.sacks["default"] : ELoot.data.sacks[item.type]
            ELoot.silent_command("open ##{ELoot.data.sacks[container].id}",ELoot.data.silent_open)
            ELoot.silent_command("open ##{ELoot.data.sacks["default"].id}",ELoot.data.silent_open) unless container == ELoot.data.sacks["default"] 
            ELoot.drag(item, container)
          end
        end
      end

      if search_refill_hand
        waitrt?
        fill_hand
      end

      # if the setting is on always end in defensive
      ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type) #skins type (blunt/dagger) group of dead critters
      return if objs.empty?

      # Set some stuff up to fix skinning for blunt since it requires two hands(one empty)
      @swap_back_blunt = false
      @normal_fill_hand = false
      @blunt_fill_hands = false
      @blunt_fill_right_hand = false
      @blunt_fill_left_hand = false

      waitrt?

      # Find our skinner
      skinner = ELoot.find_skinner(type)
      
      return if skinner.nil? && ((!ELoot.data.settings[:skin_weapon].empty? && type == :normal) || (!ELoot.data.settings[:skin_weapon_blunt].empty? && type == :blunt))
      
      has_skinner = [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

      if type == :normal
        if !has_skinner && !checkright.nil? && !checkleft.nil?
          empty_hand
          @normal_fill_hand = true
        end
      elsif type == :blunt
        if !has_skinner
          empty_hands
          @blunt_fill_hands = true
        else
          if GameObj.right_hand.id == skinner.id
            if !GameObj.left_hand.id.nil?
              empty_left_hand
              @blunt_fill_left_hand = true
            end
          elsif GameObj.left_hand.id == skinner.id
            if !GameObj.right_hand.id.nil?
              empty_right_hand
              @blunt_fill_right_hand = true
              fput "swap"
              @swap_back_blunt = true
            end
          end
        end
      end

      unless has_skinner
        until [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
          waitrt?
          ELoot.drag(skinner, 'hand')
          pause 0.2
        end
        now_has_skinner = [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
          Spell['Sigil of Resolve'].affordable? &&
          !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = Regexp.union(
        /You skinned/i,
        /You botched/i,
        /already been/i,
        /cannot skin/i,
        /must be a member/i,
        /can only skin/i,
        /You are unable to break through/i,
        /You break through the crust of the/i,
        /You crack open a portion/i,
        /Because your account is free/i,
      )

      break_match = Regexp.union(
        /You break through the crust of the .+ and withdraw (.+)!/i,
        /You crack open a portion of the .+ and uncover (.+)!/i,
      )

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id}#{(has_skinner || now_has_skinner) ? " #{skinner_hand}" : ''}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?
      ELoot.drag(skinner, ELoot.data.skinsheath) if !has_skinner
      if @swap_back_blunt
        fput "swap"
      end
    end

    def self.skin(objs = GameObj.dead.to_a) #determines what to skin
      objs = objs.reject do |obj|
        ELoot.data.settings[:unskinnable].index(obj.name) > -1 ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/ ||
          ELoot.data.settings[:skin_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:skin_exclude])
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      stance = checkstance
      unless standing?
        ELoot.change_stance('offensive') if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
        ELoot.change_stance(stance) if checkstance != stance
      end
    end
  end #End of Loot

  # Sell is a module that handles selling loot
  module Sell

    def self.hands_free 

      #Method to make sure we have empty hands for selling
      unless GameObj.right_hand.id.nil?
        result_right = Lich::Stash::add_to_bag(ELoot.data.sacks["default"], GameObj.right_hand)
      end
      
      unless GameObj.left_hand.id.nil?
        result_left = Lich::Stash::add_to_bag(ELoot.data.sacks["default"], GameObj.left_hand)
      end
                 
      if result_left == false || result_right == false
        ELoot.msg(type = "orange", " Can't seem to empty your hands!")
        ELoot.msg(type = "orange", " Please make some space and try again.")
        exit
      end
        
      
    end

    def self.save_trash_box(box)
    
      #Save the box if we want to sell it
      if ELoot.data.settings[:sell_loot_types].include?("box") && box.contents.empty? && box.name =~ /gold|mithril|silver/
        Loot.single_drag(box)
        return
      end
      
      trash = ELoot.find_trash
      
      if trash.nil?
        fput("drop ##{box.id}")
      else
        2.times do
          if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
            fput("put ##{box.id} in ##{trash.id}")
            sleep(0.5)
          end       
        end
         
      end

      fput("drop ##{box.id}") if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
    
    
    end

    
    def self.box_in_hand #Fixme
      
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
      
      item = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.type =~ /box/}
      lines = ELoot.silent_command("look in ##{item.id}",/There is nothing|In the|That is closed/)
      if lines.any?{ |line| line =~ /There is nothing|In the/i }
        empty_hands
      end
 
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
      
      if GameObj.left_hand.type == "box"
        fput "swap"
      end
      
      unless GameObj.left_hand.id.nil?
        result_left = Lich::Stash::add_to_bag(ELoot.data.sacks["default"], GameObj.left_hand)
        if result_left == false 
          ELoot.msg(type = "orange", " Can't seem to empty your left hand!")
          ELoot.msg(type = "orange", " Please make some space and try again.")
          exit
        end
      end
         
      unless ELoot.data.settings[:sell_locksmith_pool] || ELoot.data.settings[:sell_locksmith]
        ELoot.msg("error", "** There is a box in your hand but no selling methods selected! Please run ;eloot setup to fix. Exiting...")
        exit
      end
    
      if GameObj.right_hand.type == "box"
        box = GameObj.right_hand
      else
        ELoot.msg("error", "** This shouldn't happen. Report this to Elanthia-Online. A log is helpful. Exiting...")
        exit
      end
    
      ELoot.withdraw_silver(8000 - ELoot.check_silver) 
      
      box = ELoot.unphase_box(box)
      
      if ELoot.data.settings[:sell_locksmith_pool]
        ELoot.go2('locksmith pool')
        if (worker = GameObj.npcs.find { |npc| npc.name == ELoot.room_meta('boxpool:npc') }).nil?
          ELoot.msg("info", " Failed to find the locksmith pool NPC")
          ELoot.msg("info", " Update your map db; ;repository download-mapdb")
          ELoot.msg("info", " If the error persists then report this to Elanthia-Online")
          return
        end
    
             
        if ELoot.data.settings[:sell_locksmith_pool_tip_percent]
          percent = ' PERCENT'
        else
          percent = ''
        end

        fput("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}")
        match = /You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
        res = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
       if res =~ /already (unlocked|open)/
         Loot.box_loot(box)
       end
      end
      
      return if GameObj.right_hand.id.nil?
      
      if ELoot.data.settings[:sell_locksmith]
        ELoot.go2('locksmith')
        if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
          dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

          if table.contents.nil?
            error('failed to find table contents')
          else
            activator = nil
            if table.contents.any? { |obj| obj.noun == 'bell' }
              activator = 'ring bell'
            elsif table.contents.any? { |obj| obj.noun == 'keys' }
              activator = 'pull keys'
            elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
              activator = 'ring chime'
            end

            res = dothistimeout(activator, 3, /Gimme ([\d,]+) silvers/)
            ELoot.msg "info", ' Unknown locksmith response' unless res
            res = dothistimeout('pay', 3, /accepts|have enough/)
            Loot.box_loot(box)
            
          end
        end
      end  
      
      unless GameObj.right_hand.id.nil?
        ELoot.msg("error", "** Something is wrong. Can't empty hands! Exiting...")
        exit
      end
        
        
    end

    def self.dump_herbs_junk
  
      return unless ELoot.data.settings[:sell_loot_types].include?("herb") || ELoot.data.settings[:sell_loot_types].include?("junk")
      
      dump_stuff = false
      
      #Only checking default && overflow
      sacks = [ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]      
      sacks.each{ |sack| ELoot.check_sell_container(sack) if @sell_containers.include?(sack) && ELoot.data.settings[:keep_closed]}
           
      sacks.each{ |sack|
        next if sack.nil?
        
        sack.contents.each{|item|       
          if (item.type =~ /herb/ && ELoot.data.settings[:sell_loot_types].include?("herb")) || (item.type =~ /junk/ && ELoot.data.settings[:sell_loot_types].include?("junk"))
            dump_stuff = true
            break
          end                  
        }
        
        break if dump_stuff     
      }
      
      return unless dump_stuff
      
      #going here because they have trash cans. Don't want to litter
      ELoot.go2('locksmith pool')
      
      trash = ELoot.find_trash
      
      if trash.nil?
        ELoot.msg("info", " No trashcan found! Skipping herb/junk disposal so as not to litter and be a pest.")
        return
      end
      
      sacks.each{ |sack|
        next if sack.nil?
        
        sack.contents.each{|item| 
          if (item.type =~ /herb/ && ELoot.data.settings[:sell_loot_types].include?("herb")) || (item.type =~ /junk/ && ELoot.data.settings[:sell_loot_types].include?("junk"))
            ELoot.drag(item, 'hand')  
            fput("put ##{item.id} in ##{trash.id}")
              sleep(0.25)
              if [GameObj.right_hand.id, GameObj.left_hand.id].include?(trash.id)
                fput("put ##{item.id} in ##{trash.id}")
                sleep(0.25)
              end          
          end       
        }       
      }
      
      Sell.hands_free
       
    end

    def self.appraise(item,location)
      return if item.type =~ /jewelry/ && location == "pawnshop"
      
      if item.name =~ /crystal amulet|blue crystal/
        dothistimeout "sell ##{item.id}", 5, /ask|offer/
        return
      end
      
      amount = 0
      raw = nil
      
      limit = location == "gemshop" ? ELoot.data.settings[:sell_appraise_gemshop] : ELoot.data.settings[:sell_appraise_pawnshop]
      
      high_value = /not buying anything this valuable today/
      denied = Regexp.union(
        /That thing's worth less/,
        /Can't say I'm interested/,
        /That's basically worthless here/,
        /He hands it back to you, saying/,
        /Not my line, really/,
        /not quite my field/,
        /only deal in gems and jewelry/,
        /There is nothing of value to me/,
        /Trying to pull a fast one on old Hortemeyer, are you\?/,
        /no use for that/,
        /Appraise what\?\?\?/,
      )
      appraised = /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/
      sold = Regexp.union(
        /(?:pays|hands) you [,0-9]+ silver/,
        /I don't have that much spare silver, I will have to give you a bank note for it/,
        /I'm afraid I don't have that much silver on hand.+so I'll have to give you a .+ for it./,
      )
      item_selling_match = Regexp.union(high_value,denied,appraised,sold)
      
      
      res = dothistimeout "appraise ##{item.id}", 3, item_selling_match
     # lines = ELoot.silent_command("appraise ##{item.id}",/You ask/)
   
     # res = lines.find{ |line| line =~ appraised}
      if res =~ appraised
        raw = $1
        amount = $1.delete(",").to_i
      end        
 
      if amount > limit.to_i 
        ELoot.msg("info", " The #{item} appraises for #{raw}. That's above your settings.")
        ELoot.drag(item, 'default')
        return
      elsif amount < limit.to_i && amount != 0
        dothistimeout "sell ##{item.id}", 5, /ask|offer/
        return
      end
   
      ELoot.drag(item, 'default')
 
      return 
     
    end

    def self.gold_rings
    
      return unless ELoot.data.settings[:sell_gold_rings]
    
      ELoot.go2("chronomage")
    
      Sell.hands_free
        
      unless npc = GameObj.npcs.find { |npc| npc.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
      end
   
      unless npc.nil?
        chrono_sacks = [ELoot.data.sacks["jewelry"], ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]      
        chrono_sacks.each{ |sack| ELoot.open_single_container(sack) }        
             
        chrono_sacks.each{ |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ ELoot.data.regex_gold_rings }.empty?
        
          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.name =~ ELoot.data.regex_gold_rings
            $sell_ignore.push(item.id) 
            ELoot.drag(item, 'hand')
            fput "give ##{item.id} to ##{npc.id}"
            sleep 0.2
            
            Sell.hands_free         
          end       
        }      
      end
    end

    def self.locksmith_open(box, activator)
    
      lines = ELoot.silent_command("look in ##{box.id}",/There is nothing|In the #{box.name}|That is closed|shifting form/)
      return if lines.any?{ |line| line =~ /There is nothing|In the/i }
    
      ELoot.drag(box, 'hand')
      box = ELoot.unphase_box(box)

      res = dothistimeout(activator, 3, /Gimme ([\d,]+) silvers/)
      ELoot.msg "info", 'unknown locksmith response' unless res

      res = dothistimeout('pay', 3, /accepts|have enough/)
      if res =~ /have enough/
        ELoot.drag(box, 'default')
        ELoot.withdraw_silver(8000 - ELoot.check_silver)
        ELoot.go2('locksmith')

        return Sell.locksmith_open(box, activator)
      end

      Loot.box_loot(box)
    end

    def self.locksmith_pool(boxes)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false
      ELoot.withdraw_silver(8000 - ELoot.check_silver) if boxes.length.positive?
      ELoot.go2('locksmith pool')

      if (worker = GameObj.npcs.find { |npc| npc.name == ELoot.room_meta('boxpool:npc') }).nil?
        ELoot.msg("info", " Failed to find the locksmith pool NPC")
        ELoot.msg("info", " Update your map db; ;repository download-mapdb")
        ELoot.msg("info", " If the error persists then report this to Elanthia-Online")
        return
      end

      empty_right_hand
      ELoot.wait_for_disk

      boxes.each do |box|
 
        lines = ELoot.silent_command("look in ##{box.id}",/There is nothing|In the #{box.name}|That is closed|shifting form/)
        next if lines.any?{ |line| line =~ /There is nothing|In the/i }
   
        ELoot.drag(box, 'hand')
 
        box = ELoot.unphase_box(box)
  
        percent = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ' PERCENT' : ''
 
        match = /You want a locksmith|You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
        result = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
        if result =~ /already (unlocked|open)/
         Loot.box(box)
        else
          res = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)        
          if res =~ /You don't have that much/
            ELoot.withdraw_silver(8000 - ELoot.check_silver)
            ELoot.go2('locksmith pool')
            fput("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}")
            dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)  
          elsif res =~ /already holding as many boxes/
            sleep(0.250)
            Loot.single_drag(box)
            break
          elsif res =~ /already (unlocked|open)/
           Loot.box(box)
          end
        end
        sleep(0.250)
        Loot.single_drag(box) if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      end

      
      # retrieve (and loot) any boxes in the pool
      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)
        # no more boxes left
        break if res !~ /Alright, here's your/

        box = nil
        if GameObj.right_hand.type =~ /box/
          box = GameObj.right_hand
        elsif GameObj.left_hand.type =~ /box/
          box = GameObj.left_hand
        else
          ELoot.msg("error", " Failed to find the box you were supposed to get; report this to Elanthia-Online")
        end

        Loot.box_loot(box)

        sleep(0.250)
      end
    end

    def self.locksmith(boxes)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      boxes = boxes.select { |box| box.type =~ /box/i }

      return if boxes.empty?

      silver = ELoot.check_silver

      ELoot.withdraw_silver(8000 - silver) if silver < 8000

      ELoot.go2('locksmith')
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            boxes.each { |box| 
              Sell.hands_free
              Sell.locksmith_open(box, activator)          
            }           
          else
            ELoot.msg("error", " Failed to find a bell, keys, or chime on the table")
          end
        end
      else
        ELoot.msg("error", " Failed to find a table")
      end
    end

    def self.collectibles 
   
      return unless ELoot.data.settings[:sell_collectibles]
      
      places = Array.new
      places.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
      places.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?
      
      go_place = Room.current.find_nearest(places)

      ELoot.go2(go_place)

      Sell.hands_free

      ELoot.data.sacks.keys.each{ |item|
             
        ELoot.data.sacks[item].contents.each { |thing| 
          next if $sell_ignore.include?(thing.id)
          next unless thing.type == "collectible"
          next if ELoot.data.ready_list.find { |_, name| name.include?(thing.name) }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/
          $sell_ignore.push(thing.id)          
          ELoot.drag(thing, 'hand')            
          dothistimeout("deposit ##{thing.id}", 3, /You hand your/)
          
          Sell.hands_free
        }       
      }
     
    end

    def self.furrier
    
      ELoot.go2("furrier")
    
      Sell.hands_free
    
      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./     
      skin_sacks = [ELoot.data.sacks["skin"], ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]      
  
      skin_sacks.each{ |sack|
        next if sack.nil?
        next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
        next if sack.contents.find_all { |obj| obj.type =~ /skin|reagent/ }.empty?
        
        bulk_sell = true
        bulk_sell = false if bounty? =~ skin_match
        
        unless ELoot.data.settings[:sell_exclude].empty? 
          sack.contents.each do |item| 
            if item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/  && item.type =~ /skin|reagent/
              bulk_sell = false
            end       
          end
        end
        
        if bulk_sell 
          ELoot.drag(sack, 'hand') if [checkleft, checkright].index(sack.noun).nil?
          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          dothistimeout("wear ##{sack.id}", 3, /You/i)
          sleep 0.5
        else
          sack.contents.each do |item| 
            next if $sell_ignore.include?(item.id)
            next unless item.type =~ /skin|reagent/ && item.sellable =~ /furrier/
            next unless item.type.split(',').any? { |type| type =~ /^#{@types.join('|')}$/ }
            $sell_ignore.push(item.id) 
            ELoot.drag(item, 'hand')
            dothistimeout "sell ##{item.id}", 5, /ask|offer/           
          end
        end
        Sell.hands_free
      }
      
    end
    
    def self.gemshop
    
      ELoot.go2("gemshop")
      
      Sell.hands_free
      
      gem_sacks = [ELoot.data.sacks["gem"], ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]      
     
      gem_sacks.each{ |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("gemshop") }.empty?
    
        #Bulk sell sack if it has gems and no exclusions
        if (ELoot.data.settings[:sell_exclude].empty? || (sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ }).empty?) && sack.contents.find_all { |obj| obj.type =~ /gem/ }.length.positive? && ELoot.data.settings[:sell_loot_types].include?("gem")      
            ELoot.drag(sack, 'hand') if [checkleft, checkright].index(sack.noun).nil?
            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
            dothistimeout("wear ##{sack.id}", 3, /You/i)
            sleep 0.5
            Sell.hands_free       
        end  
        
        #Loop thru remaining contents and sell/appraise whatever is left
        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable.include?("gemshop") || item.noun =~ /thorn|berry/ || item.type =~ /scarab/
          next unless item.type.split(',').any? { |type| type =~ /^#{@types.join('|')}$/ }
          next if item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?         
          next if ELoot.data.settings[:sell_gold_rings] && item.name =~ ELoot.data.regex_gold_rings
          $sell_ignore.push(item.id) 
          if item.type =~ /cursed/ && (!Spell[315].known? || !ELoot.data.settings[:sell_loot_types].include?("cursed"))
            ELoot.msg("info", "** #{item.name} is cursed. Can't touch that. You'll need to take a look")
            next
          elsif item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
            Spell[315].cast("at ##{item.id}")
          end
          
          ELoot.drag(item, 'hand')
          
          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?          
            Sell.appraise(item,"gemshop")
          else            
            dothistimeout "sell ##{item.id}", 5, /ask|offer/
          end
          
          Sell.hands_free 
        end
              
      }
       
    end
    
    def self.consignment
      
      ELoot.go2("consignment")
  
      Sell.hands_free
      
      consignment_sacks = [ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]]]
      
      consignment_sacks.each{ |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("consignment") }.empty?  
        sack.contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.sellable.include?("consignment")
          next unless thing.type.split(',').any? { |type| type =~ /^#{@types.join('|')}$/ }
          next if ELoot.data.ready_list.find { |_, name| name.include?(thing.name) }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/
          $sell_ignore.push(thing.id)          
          ELoot.drag(thing, 'hand')            
          dothistimeout "sell ##{thing.id}", 5, /ask|offer/
          
          Sell.hands_free
        }       
      }
              
    end
    
    def self.pawnshop
   
      ELoot.go2("pawnshop")

      Sell.hands_free

      containers = ELoot.data.sacks.keys.dup
      
      if ELoot.data.settings[:use_disk] 
        ELoot.wait_for_disk
        containers.push("disk")  
      end
   
      containers.each{ |item|
     
        bag = item == "disk" ? ELoot.data.disk : ELoot.data.sacks[item] 
   
        bag.contents.each { |thing|
      
          next if $sell_ignore.include?(thing.id)
          next if item != thing.type && item !~ /default|#{ELoot.data.settings[:overflow_container]}|disk/ 
          next unless (thing.sellable.include?("pawnshop") && !thing.sellable.include?("gemshop")) || thing.type == "box"
          next if ELoot.data.ready_list.find { |_, name| name.include?(thing.name) }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next unless thing.type.split(',').any? { |type| type =~ /^#{@types.join('|')}$/ }
          next if thing.name =~ /bound/
          next if ELoot.data.settings[:sell_gold_rings] && thing.name =~ ELoot.data.regex_gold_rings
          $sell_ignore.push(thing.id) unless thing.type =~ /box/ 
          if thing.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
            lines = ELoot.silent_command("read ##{thing.id}", /It takes you a moment|There is nothing there to read|You can't do that/) 
            next if lines.any?{ |line| line =~ /\((?:#{ELoot.data.settings[:sell_keep_scrolls].join("|")})\)/i }
          end
          next unless ELoot.decurse(thing)
          if thing.type =~ /cursed/ && (!Spell[315].known? || !ELoot.data.settings[:sell_loot_types].include?("cursed"))
            ELoot.msg("info", "** #{thing.name} is cursed. Can't touch that. You'll need to take a look")
            next
          elsif thing.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
            Spell[315].cast("at ##{thing.id}")
          end
                     
          ELoot.drag(thing, 'hand')
          if (thing.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?) || thing.type =~ /uncommon|weapon|armor/ 
            Sell.appraise(thing,"pawnshop")
          elsif thing.type =~ /box/
              lines = ELoot.silent_command("look in ##{thing.id}",/There is nothing|In the|That is closed/)
              if lines.any?{ |line| line =~ /There is nothing|In the/i }
                thing.contents.each{|box_item|
                    if box_item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed") 
                      Spell[315].cast("at ##{box_item.id}")
                    elsif box_item.type =~ /cursed/ && !Spell[315].known?
                      ELoot.msg("info", "** #{box_item.name} is cursed. Stowing box. You'll need to take a look")
                      ELoot.drag(thing, 'default')
                    else
                      ELoot.drag(box_item, 'default')
                    end
                }
                dothistimeout "sell ##{thing.id}", 5, /ask|offer/
              elsif lines.any?{ |line| line =~ /That is closed/i }
                #This shouldn't happen
                ELoot.msg("info", "** #{thing.name} is closed. Storing box...")
                ELoot.drag(thing, 'default')
              end
          else           
            dothistimeout "sell ##{thing.id}", 5, /ask|offer/           
          end 
      
          Sell.hands_free
        }       
      }
          
    end

    def self.stow_notes
      ELoot.drag(GameObj.right_hand, 'default') if GameObj.right_hand.noun =~ /(?:note|scrip|chit)$/
      ELoot.drag(GameObj.left_hand, 'default') if GameObj.left_hand.noun =~ /(?:note|scrip|chit)$/
    end

    def self.sell
    
      $sell_ignore ||= Array.new
       
      fput('unhide') if (hidden? || invisible?)
   
      Sell.box_in_hand
      
      empty_hands
           
      if !checkright.nil? || !checkleft.nil?
        ELoot.msg("error", "** Something is wrong. Can't empty hands! Report this to Elanthia-Online. A log is helpful. Exiting...")
        exit
      end
      
      ELoot.msg("debug", "ELoot.sell: Locating boxes")
      boxes = ELoot.find_boxes
      cur_len = boxes.length.to_i
      ELoot.msg("debug", "ELoot.sell: Boxes length = #{cur_len}")

      #Process boxes in the locksmithpool
      if ELoot.data.settings[:sell_locksmith_pool] && boxes.length.positive?
        Sell.locksmith_pool(boxes)

        # refresh the boxes
        boxes = ELoot.find_boxes
      end

      #Sell off any remaining boxes
      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?
   
      @selling = Array.new
      @types = Array.new
      
      #Chech which type of loot we are going to sell
      ELoot.data.settings[:sell_loot_types].each { |type| @types.push(type)}

      ELoot.wait_for_disk

      all_contents = Array.new
      ELoot.data.sacks.keys.each{ |item|
        ELoot.check_sell_container(item)
        all_contents += ELoot.data.sacks[item].contents.to_a
      }
   
      all_contents += ELoot.data.disk.contents.to_a
   
      all_contents.each{ |thing|
        next if $sell_ignore.include?(thing.id)
        next if @selling.any? {|i| thing.sellable.include?(i) }
        next if ELoot.data.ready_list.find { |_, name| name.include?(thing.name) }
        next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
        next if thing.name =~ /bound/

        if thing.name =~ ELoot.data.regex_gold_rings && ELoot.data.settings[:sell_gold_rings]
          @selling.push("chronomage") unless @selling.include?("chronomage")
        elsif thing.type =~ /scarab/ && @types.include?("scarab")
          @selling.push("gemshop") unless @selling.include?("gemshop")
        elsif thing.type == "gem" && @types.include?("gem") && thing.noun =~ /thorn|berry/
          @selling.push("gemshop") unless @selling.include?("gemshop")
        elsif thing.type == "collectible" && ELoot.data.settings[:sell_collectibles]
          @selling.push("collectibles") unless @selling.include?("collectibles")
        elsif ELoot.data.settings[:sell_loot_types].include?("box") && thing.name =~ /gold|mithril|silver/ && thing.type == "box"
          @selling.push("pawnshop") unless @selling.include?("pawnshop")
        elsif !thing.sellable.nil? && thing.type.split(',').any? { |type| type =~ /^#{@types.join('|')}$/ } 
          thing.sellable.to_s.split(',').each{ |location|
            @selling.push(location) unless @selling.include?(location)             
          }       
        end     
      }
      #  ELoot.data.regex_gold_rings    
      ELoot.msg("debug", "Places to go: #{@selling}")
 
      #if nothing to sell close any containers we opened and return
      unless @selling.length.positive?
        ELoot.deposit_silver
        Sell.dump_herbs_junk
        ELoot.close_sell_containers if ELoot.data.settings[:keep_closed]  
        return
      end
           
      rooms = Array.new
      @selling.each{ |shop| 
        if shop == "collectibles"
          col = Array.new
          col.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
          col.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?
          rooms.push(Room.current.find_nearest(col))
        elsif shop == "chronomage"
          next if Room.current.location =~ /Mist Harbor|Isle of Four Winds|Western Harbor/
          rooms.push(Room.current.find_nearest_by_tag(shop))
        else
          rooms.push(Room.current.find_nearest_by_tag(shop))
        end
      }
 
      rooms = rooms.reject do |room| room.nil? end
 
      where_is_previous_var, where_is_shortest_distances_var = Room.current.dijkstra
      shortest_path = rooms.uniq.sort { |a,b| where_is_shortest_distances_var[a] <=> where_is_shortest_distances_var[b] }
  

      shortest_path.each{ |location|
        Sell.furrier if Room[location].tags.include?("furrier")
        Sell.gemshop if Room[location].tags.include?("gemshop")
        Sell.consignment if Room[location].tags.include?("consignment")
        Sell.pawnshop if Room[location].tags.include?("pawnshop")
        Sell.collectibles if Room[location].tags.include?("collectibles") || Room[location].tags.include?("collectible")
        Sell.gold_rings if Room[location].tags.include?("chronomage")           
      }
           
      Sell.hands_free
     
      ELoot.deposit_silver
      
      #If herb or junk is checked for selling we dump it. Only default and overflow
      Sell.dump_herbs_junk
      
      #Close any containers that were opened
      ELoot.close_sell_containers if ELoot.data.settings[:keep_closed]
      	     
      fill_hands
 
    end
    
    def self.test
     
      echo "--------------- Settings ---------------"
      echo *ELoot.data.settings
      echo "----------------------------------------"
      echo ""
      echo "--------------- Sacks ------------------"
      echo *ELoot.data.sacks
      echo "----------------------------------------"
      echo ""
      echo "--------------- Contents ---------------"
     
      ELoot.data.sacks.keys.each{ |item|      
        ELoot.check_sell_container(ELoot.data.sacks[item])
        ELoot.data.sacks[item].contents.each { |thing| 
          echo "Name: #{thing.name} Type: #{thing.type} Sellable: #{thing.sellable}"       
        }       
      }
      
      echo "----------------------------------------"
      
    end
    
  end
end

if script.vars.any? { |var| var =~ /^--debug=(on|off|true|false|yes|no)$/i }
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  ELoot.load(ELoot.load_profile()) unless ELoot.data
  ELoot::Setup.update_setting(:debug, fix_option[$1])
  ELoot.data.settings[:debug] = fix_option[$1]
  ELoot.save_profile()
  exit
end

# Silence
silence_me if ELoot.data.settings[:silence]

# Initialize default settings
unless ELoot.data
  ELoot.load(ELoot.load_profile())
  ELoot.data.sacks.keys.each{ |item| ELoot.open_single_container(ELoot.data.sacks[item])}
  ELoot.disk_usage
end

#Sorter shows inventory checks so we kill it and restart
ELoot.manage_sorter

# Default to loot
if script.vars[1].nil?

  ELoot.disk_usage

  ELoot.loot

  #Close any containers that were opened
  ELoot.close_sell_containers if ELoot.data.settings[:keep_closed]

  exit
end

# This allows partial matches the same way Gemstone works.
# e.g., ;eloot sel would match ;eloot sell
command = '^box^help^setup^sell^pool^load^list^test'

# No match - show help message
unless (index = (command =~ /\^#{script.vars[1]}/))
  ELoot.help
  exit
end

# Got a match, strip the command down to the parts in between the ^
start = index + 1
stop = command.index('^', index + 1) - 1


case command[start..stop]
when 'box'
  ELoot::Loot.box_loot(GameObj.right_hand)
  ELoot.close_sell_containers if ELoot.data.settings[:keep_closed]
when 'help'
  ELoot.help
when 'list'
  ELoot::Setup.new(ELoot.data.settings).list if script.vars[2].nil?
  ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: script.vars[2]) if !script.vars[2].nil?
when 'sell'
  room = Room.current.id
  ELoot.disk_usage 
  ELoot.sell
  ELoot.go2(room)
when 'pool'
  room = Room.current.id
  ELoot.disk_usage 
  boxes = ELoot.find_boxes
  ELoot::Sell.locksmith_pool(boxes)
  ELoot.go2(room)
when 'setup'
  ELoot::Setup.new(ELoot.data.settings).start
  ELoot.load(ELoot.load_profile())
  ELoot.data.sacks.keys.each{ |item| ELoot.open_single_container(ELoot.data.sacks[item])}
  ELoot.disk_usage
when 'load'
  ELoot.load(ELoot.load_profile)
  ELoot.data.sacks.keys.each{ |item| ELoot.open_single_container(ELoot.data.sacks[item])}
  ELoot.disk_usage
when 'test'
  ELoot::Sell.test
end
