=begin
  version: 1.2.0, 1.3.0

  Shows system notifications when:
    * someone messages you on lnet
    * someone whispers to you
    * someone speaks to you
    * something generally bad happens to your character

  supported:
    Linux (lib-notify)
    OSX   (display)

  contributions:
    Dalem - OSX info

  documentation:
    ;notify                      turn on the notify watcher
    ;notify sounds               list all sounds that notify can find on your system
    ;notify sounds <substring>   list all sounds that match a substring
    ;notify set-sound <sound>    set the sound to play when 
    ;notify mute                 turns off sound
  
  usage:
    # example how to add your own hooks
    unless Module.const_get("Notify").is_a?(Module)
      start_script "notify"
    end
    # we must set a sound for this script
    # because it is in a different thread
    Notify::Sounds.set "zelda/email"
  
    Notify.notify(from: "taters", body: "i'm important", type: Script.current.name)

  notes:
    * to be able to use Notify from another script it must be ;trusted
      otherwise it be available the Main (global) context
    * will no longer ping you about stuns while doing Dark Chamber reps

  changelog:
    2-15-2017 add danger notifications for low health and stun
    2-17-2017 add pattern matching to ;notify sounds command
    2-18-2017 add spinners to notifications

  Required: Lich 4.3.12, lib-notify
  Author: Ondreian
  Tags: util
  
=end
require "ostruct"

class String
  def is_i?
    !!(self =~ /\A[-+]?[0-9]+\z/)
  end
end

class MatchData
  def to_struct
    OpenStruct.new to_hash
  end

  def to_hash
    Hash[self.names.zip(self.captures.map(&:strip).map do |capture|  
      if capture.is_i? then capture.to_i else capture end
    end)]
  end
end

class Hash
  def to_struct
    OpenStruct.new self
  end
end

module OS
  def OS.windows?
    (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil
  end

  def OS.mac?
   (/darwin/ =~ RUBY_PLATFORM) != nil
  end

  def OS.unix?
    !OS.windows?
  end

  def OS.linux?
    OS.unix? and not OS.mac?
  end
end

module Notify
  HELP = """
    ;notify@1.0.0

    ;notify                      turn on the notify watcher
    ;notify sounds               list all sounds that notify can find on your system
    ;notify set-sound <sound>    set the sound to play when 
    ;notify play <sound>         play a sound one time without changing any settings
    ;notify mute                 turns off sound
  """

  PRIVATE_MESSAGE = /^\[Private\]\-GSIV:(?<from>.*?): "(?<body>.*?)"/
  OOC_WHISPER     = /^\(OOC\) (?<from>.*?)'s player whispers(| to the group), "(?<body>.*?)"$/
  IC_WHISPER      = /^(?<from>.*?) whispers(| to the group), "(?<body>.*?)"$/
  SPEECH          = /^Speaking (.*?|)to you, (?<from>.*?) (.*?), "(?<body>.*?)"$/
  SPINNER         = /^(.*?) comes to a stop pointing directly at you!$/
  LEVELED_UP      = /^You are now level (?<level>\d+)!$/
  SHOP_SALE       = /^Your (?<item>.*?) just sold for (?<silvers>.*?) silvers from/
  RAFFLE          = /^You\ssense\syou\shave\sjust\swon\sa\sraffle/

  MESSAGE         = Regexp.union(PRIVATE_MESSAGE, IC_WHISPER, OOC_WHISPER, SPEECH, SPINNER, LEVELED_UP)
  DURATION        = :duration
  APP_NAME        = "lnet"
  ICON            = "mail-send-receive"
  TIMEOUT         = 30 # seconds
  
  TRAINING_AREAS  = [16994]

  NOTIFY = if OS.linux?
    "notify-send"
  elsif OS.mac?
    "osascript"
  else
    nil
  end

  def self.which?(cmd)
    exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
    ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
      exts.each { |ext|
        exe = File.join(path, "#{cmd}#{ext}")
        return exe if File.executable?(exe) && !File.directory?(exe)
      }
    end
    return nil
  end
  ##
  ## system messages on Linux are of a fixed interval
  ## you cannot easily configure this
  ## 
  def self.show(message)
    message = message.to_struct if message.is_a?(Hash)
    title = [message.from, Char.name].join(" => ")
    if OS.linux?
      %x{#{NOTIFY} "#{title} [#{message.type}]" "#{message.body}" --icon=#{ICON} --app-name=#{APP_NAME}}
    elsif OS.mac?
      %x{#{NOTIFY} -e 'display notification "#{message.body}" with title "#{title} #{message.type}"'}
    else
      # silence is golden
    end
  end

  def self.notify(incoming)
    incoming = incoming.to_struct if incoming.is_a?(Hash)
    show incoming
    Sounds.play Sounds.current
  end

  def self.duration=(milliseconds)
    Settings[DURATION] = milliseconds
    Settings.save
  end

  def self.duration
    Settings[DURATION] ||= 3000
  end

  def self.ignore(*chars)
    Settings[:ignored] = ignored + chars
    Settings.save
  end

  def self.unignore(*chars)
    Settings[:ignored] = ignored - chars
    Settings.save
  end

  def self.ignored
    Settings[:ignored] ||= []
  end

  def self.play(sound)
    Sounds.play sound
  end

  def self.watch!
    fork!

    before_dying {
      @@background.join.kill
    }

    while line = get
      if line =~ MESSAGE
        if incoming = line.match(PRIVATE_MESSAGE).to_struct
          incoming[:type] = "lnet"
        elsif incoming = line.match(SPEECH).to_struct
          incoming[:type] = "speech"
        elsif incoming = line.match(OOC_WHISPER).to_struct
          incoming[:type] = "whisper:ooc"
        elsif line =~ SPINNER
          incoming = OpenStruct.new(
            from: :merchant,
            type: :spinner,
            body: "#{Char.name} has been spun for a service"
          )
        elsif line =~ RAFFLE
          incoming = OpenStruct.new(
            from: :raffle,
            type: :win,
            body: "#{Char.name} won a raffle"
          )
        elsif data = line.match(LEVELED_UP).to_struct
          incoming = OpenStruct.new(
            from: :game,
            type: :level_up,
            body: "#{Char.name} is now level #{data.level}"
          )
        elsif data = line.match(SHOP_SALE).to_struct
          incoming = OpenStruct.new(
            from: :shop,
            type: :sale,
            body: line,
          )
        else incoming = line.match(IC_WHISPER).to_struct
          incoming[:type] = "whisper:ic"
        end
        if should_notify_about?(incoming)
          notify(incoming)
        end
      end
    end
  end

  IGNORED_BODIES = /^Clearcheck\.|^Clear:/

  def self.should_notify_about?(incoming)
    !ignored.include?(incoming.from) &&
      incoming.body !~ IGNORED_BODIES
  end

  def self.fork!
    @@background = Thread.new {
      ttl = nil
      loop {
        sleep 0.15
        ttl = nil if ttl < Time.new - TIMEOUT
        next unless ttl.nil?
        if message = should_inform_user?
          ttl = Time.now
          notify(
            from: "notify",
            type: "danger",
            body: message,
          )
        end
      }
    }
  end

  def self.should_inform_user?
    if stunned? && !TRAINING_AREAS.include?(Room.current.id)
      "#{Char.name} has been stunned!"
    elsif percenthealth < 90
      "#{Char.name}'s health is at #{percenthealth}%"
    else
      false
    end
  end

  class Sounds
    SOUNDS_DIR = if OS.linux?
      ["/usr/share/sounds/"] 
    elsif OS.mac?
      [File.expand_path("~/Library/Sounds/"), "/System/Library/Sounds/"]
    else 
      []
    end

    BIN = if OS.linux?
      "paplay"
    elsif OS.mac?
      "afplay"
    else
      nil
    end
    
    def self.to_a
      SOUNDS_DIR.map do |dir|
        Dir[dir + "**/*"]  
      end.flatten
      .select do |path|
        path =~ /\.([a-z0-9A-Z]+)$/
      end
    end

    def self.match(name)
      to_a.select do |file| file =~ /#{name}/i end
    end

    def self.[](name)
      to_a.find do |file| file =~ /#{name}/i end
    end

    def self.current
      Settings[:sound]
    end

    def self.full_sound_path
      self[current]
    end

    def self.set(sound)
      Settings[:sound] = sound
      Settings.save
    end

    def self.play(sound = full_sound_path)
      %x{#{BIN} #{self[sound]}} if Notify.which?(BIN) && sound
    end
  end
end

if Script.current.vars.first == "help"
  respond Notify::HELP
  exit
end

if Script.current.vars.include?("sounds")

  sounds = Notify::Sounds.match(Script.current.vars.last || "/").map do |file|  
    file.split("/")[-2..-1].join("/")
  end
  respond sounds.sort.join("\n")
  exit
end

if Script.current.vars.include?("play")
  respond Notify::Sounds[Script.current.vars.last]
  Notify::Sounds.play Notify::Sounds[Script.current.vars.last]
  exit
end

if Script.current.vars.include?("mute")
  Notify::Sounds.set nil
  respond "[notify] muted"
  exit
end

if Script.current.vars[1] == "ignore"
  Notify.ignore *Script.current.vars[2..-1].map(&:capitalize)
  respond "ignored : " + Notify.ignored.join(", ")
  exit
end

if Script.current.vars[1] == "unignore"
  Notify.unignore *Script.current.vars[2..-1].map(&:capitalize)
  respond "ignored : " + Notify.ignored.join(", ")
  exit
end

unless Notify.which?(Notify::NOTIFY)
  raise Exception.new "expected #{Notify::NOTIFY} exectuable (notify-send) not found in $PATH"
end

if Script.current.vars.include?("set-sound")
  Notify::Sounds.set Script.current.vars.last
  if Notify::Sounds.full_sound_path
    respond "[notify] playing -> #{Notify::Sounds.full_sound_path}"
    Notify::Sounds.play Notify::Sounds[Notify::Sounds.full_sound_path]
  else
    respond "[notify] muted"
  end
  exit
end

if Script.current.vars.first
  # unhandled argument
  respond Notify::HELP
  exit
end

Notify.watch!
