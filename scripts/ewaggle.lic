=begin

  ewaggle.lic:  Spellup script for yourself and others.  This script is a rewrite of ultrawaggle from SpiffyJr, which is a heavily modified version of spellup from Shaelun and Blueland.
    ;ewaggle help

        author: elanthia-online
  contributors: Tillmen, Tysong, Deysh
          game: gs
          tags: magic, utility, spell
      required: Lich >= 5.6.0
       version: 2.0.0

  Version Control:
    Major_change.feature_addition.bugfix
  2.0.0 (2025-02-06)
    Refactor code now requires Lich 5.6.0 or better
    converted to use yaml profiles
    uses terminal-table for info, list, and help output
    added option for self when buffing a group instead of your name. Ex ;ewaggle Bil Joe self
    removed dont_cast_over parameter since its obsolete
  1.0.5 (2024-12-31):
    Bugfix in sorting of spells in cast_list and in GTK setup window
  1.0.4 (2024-07-09):
    Fix to Symbol of Mana to not spam if out of favor
  1.0.3 (2024-05-01):
    Change Char.prof to Stats.prof
  1.0.2 (2024-02-14):
    removal of CONSTANT to cleanup log output
  1.0.1 (2022-04-07):
    bugfix for reget in GTK queue
    update default cast_list for new configs
  1.0.0 (2022-04-07):
    rename waggle -> ewaggle
    Add bail mode

=end
=begin
waggle.lic prior release notes
  0.18.4 (2023-04-05):
    Update wander proc for FalseClass error
    Rubocop cleanup
    Change script.vars to Script.current.vars
  0.18.3 (2022-03-15):
    Replaced squelching of SPELL ACTIVE using Lich::Util.quiet_command_xml
  0.18.2 (2022-03-09):
    Fix for Lich 5.4.0 and Effects symbol of mana
  0.18.1 (2021-08-21):
    Updated to account for Monk and Feat mental acuity
  0.17.0 (2021-08-12):
    updated with new SPELL ACTIVE format
    updated header information for standardization
  0.16 (2020-08-21):
    added squelching of spell active output (using quiet_command from Lostranger scripts)
  0.15 (2020-08-20):
    hacked in using new SPELL ACTIVE <target> functionality
  0.14 (2019-05-11):
    fix --reserve-mana (austin-j)
  0.13 (2019-03-03):
    set refreshable_min value from CLI if present (sandersch)
  0.12 (2018-04-20):
    fix --refreshable-min command line option

=end

# fixme: option to cast high level spells first
# fixme: armor specialization
# fixme: option to not cast low duration spells on others

# Check version of Lich for compatibility
lich_gem_requires = '5.6.0'

require 'yaml'
require 'terminal-table'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

# Data
module Ewaggle
  class Data
    attr_accessor :settings, :known_spells, :did_something, :short_spell_time, :cast_list, :wander, :skip_spells, :skip_targets, :revert, :options, :cli_options

    def initialize(settings)
      @settings = settings
      @did_something = false
      @short_spell_time = 3
      @cast_list = @settings[:cast_list].map { |entry| entry[/^\d+/].to_i }
      @wander = []
      @skip_spells = []
      @skip_targets = []
      @revert = false

      @cli_options = {
        /^\-\-start[_\-]at=[0-9]+$/                          => :start_at,
        /^\-\-stop[_\-]at=[0-9]+$/                           => :stop_at,
        /^\-\-\b(?:unstackable|refreshable)[_\-]min=[0-9]+$/ => :refreshable_min,
        /^\-\-cast[_\-]list=[0-9,]+$/                        => :cast_list,
        /^\-\-use[_\-]multicast=(?:on|off)$/                 => :use_multicast,
        /^\-\-use[_\-]wracking=(?:on|off)$/                  => :use_wracking,
        /^\-\-wander[_\-]to[_\-]wrack=(?:on|off)$/           => :wander_to_wrack,
        /^\-\-use[_\-]power=(?:on|off)$/                     => :use_power,
        /^\-\-use[_\-]mana=(?:on|off)$/                      => :use_mana,
        /^\-\-use[_\-]concentration=(?:on|off)$/             => :use_concentration,
        /^\-\-bail=(?:on|off)$/                              => :bail_no_mana,
        /^\-\-skip[_\-]short(?:[_\-]spells)?=(?:on|off)$/    => :skip_short_spell,
        /^\-\-retribution[_\-]spell=(?:[0-9]+|off|none)$/    => :retribution_spell,
        /^\-\-reserve[_\-]mana=([0-9]+)$/                    => :reserve_mana,
        /^\-\-save$/                                         => :save
      }

      @options = {
        /add\b/i                                   => :cast_list,
        /^rem(?:ove)?\b|^del(?:ete)?\b/i           => :cast_list,
        /^start[_\-]at\b/i                         => :start_at,
        /^stop[_\-]at\b/i                          => :stop_at,
        /^(?:unstackable|refreshable)[_\-]?min\b/i => :unstackable_min,
        /^(?:use[_\-])?multicast\b/i               => :use_multicast,
        /^(?:use[_\-])?wracking\b/i                => :use_wracking,
        /^bail\b/i                                 => :bail_no_mana,
        /^wander(?:[_\-]to[_\-]wrack)?\b/i         => :wander_to_wrack,
        /^(?:use[_\-])?power\b/i                   => :use_power,
        /^(?:use[_\-])?concentration\b/i           => :use_concentration,
        /^(?:use[_\-])?mana\b/i                    => :use_mana,
        /^skip[_\-]short(?:[_\-]spells)\b/i        => :skip_short_spells,
        /^reserve[_\-]mana\b/i                     => :reserve_mana,
        /^retribution(?:[_\-]spell)?\b/i           => :retribution_spell
      }

      valid_retribution_spells = [
        '701', '702', '703', '705', '706', '708', '711', '713', '715', '716', '717', '718', '719', '740',
        '102', '106', '110', '111', '118', '119', '130',
        '409', '412', '413', '415', '417'
      ]

      if !valid_retribution_spells.include?(@settings[:retribution_spell]) && !@settings[:retribution_spell].to_s.empty?
        respond " #{@settings[:retribution_spell]} #{Spell[@settings[:retribution_spell]]} is not a valid retribution spell."
        respond " Please visit https://gswiki.play.net/Cloak_of_Shadows_(712) for a complete list"
        @settings[:retribution_spell] = ""
      end
    end
  end
end

# Setup
if defined?(Gtk)
  module Ewaggle
    class Setup < Gtk::Builder
      attr_accessor :settings

      @@categories = {
        general: {
          not_to_cast: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text.to_s
              end
            end
          },
          cast_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text.to_s
              end
            end
          },
          start_at: { default: 180 },
          stop_at: { default: 180 },
          refreshable_min: { default: 15 },
          use_multicast: { default: true },
          use_wracking: { default: false },
          wander_to_wrack: { default: false },
          use_power: { default: false },
          use_mana: { default: false },
          use_concentration: { default: false },
          skip_jerks: { default: false },
          skip_short_spells: { default: false },
          bail_no_mana: { default: false },
          reserve_mana: { default: 0 },
          retribution_spell: { default: "" },
          use_203: { default: false },
          use_515: { default: false },
        },
        internal: {
          debug: { default: false },
        },
      }

      def start
        @drag_key = nil
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()
        @original = settings.dup
        @silent_exit = false
        @settings = settings
        @script_name = Script.current.name.capitalize

        # Not_to_cast list needs reset if using CLI.
        reset_no_cast

        # Get script version
        version = Ewaggle.get_script_version

        # set default values if they don't exist
        @@categories.each do |_key, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end

        # remove settings that don't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}ewaggle.ui")
          add_from_string(Setup.ewaggle_ui)
          load_settings
          self['main'].keep_above = true
          self['main'].set_title "Ewaggle Setup v#{version}"
          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def reset_no_cast
        gtk_spells = []
        Spell.list.each { |spell| gtk_spells.push(spell) if (spell.known? && spell.time_per > 0 && spell.num.to_s =~ /(?:[1-4][0-9]|50|0[1-9])$/) }
        gtk_spells.sort_by!(&:num)

        gtk_spells.each do |spell|
          next if @settings[:cast_list].include?("#{spell.num}  #{spell.name}")
          @settings[:not_to_cast] << "#{spell.num}  #{spell.name}"
        end

        @settings[:not_to_cast].uniq!
      end

      # This is connected to automatically during load_settings and syncs data back to CharSettings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.class == Gtk::CheckButton
            @settings[key] = obj.active?
          elsif obj.class == Gtk::Entry
            @settings[key] = obj.text.strip
          elsif obj.class == Gtk::SpinButton
            obj.signal_connect("changed") do
              @settings[key] = obj.value
              obj.update

              # force int, we don't use floats anywhere
              @settings[key] = obj.adjustment.value.to_i
            end
          end
        end
      end

      def on_close_clicked
        # Need to update the spells
        Ewaggle.data.settings[:cast_list] = []
        self["cast_list_store"].each do |_model, _path, iter|
          Ewaggle.data.settings[:cast_list] << iter[0]
        end

        Ewaggle.data.settings[:not_to_cast] = []
        self["not_to_cast_store"].each do |_model, _path, iter|
          Ewaggle.data.settings[:not_to_cast] << iter[0]
        end

        Ewaggle.save_profile

        @silent_exit = true
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue {
          unless @silent_exit
            respond
            Lich::Messaging.msg('plain', " #{@script_name} UI closed WITHOUT saving any changes")
            Lich::Messaging.msg('plain', " Be sure to use the close button to save changes")
            respond
          end
          @running = false
        }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            builder_name = obj.builder_name.to_s
            next if (setting = Setup.get_setting(key)).nil?

            conditions = {
              "retribution_spell" => !Spell[712].known?,
              "use_wracking"      => !(Society.member == 'Council of Light' && Society.rank >= 18),
              "wander_to_wrack"   => !(Society.member == 'Council of Light' && Society.rank >= 18),
              "use_power"         => !(Society.member == 'Guardians of Sunfist' && Society.rank >= 18),
              "use_concentration" => !(Society.member == 'Guardians of Sunfist' && Society.rank >= 14),
              "use_mana"          => !(Society.member == 'Order of Voln' && Society.rank >= 13),
              "use_203"           => !Spell[203].known?,
              "use_515"           => !Spell[515].known?
            }

            # disable options and set them to false if the character can't do them
            if conditions[builder_name]
              obj.set_sensitive(false)
              @settings[key] = builder_name == "retribution_spell" ? "" : false
            end

            if obj.class == Gtk::CheckButton
              obj.active = @settings[key]
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::SpinButton
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::TreeView
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @settings[key])

              # Add Drag & Drop Support
              enable_drag_and_drop(obj, key)
            end
          end
        end
      end

      def enable_drag_and_drop(tree_view, key)
        tree_view.enable_model_drag_source(Gdk::ModifierType::BUTTON1_MASK, [Gtk::TargetEntry.new("STRING", Gtk::TargetFlags::SAME_APP, 0)], Gdk::DragAction::MOVE)

        tree_view.enable_model_drag_dest([Gtk::TargetEntry.new("STRING", Gtk::TargetFlags::SAME_APP, 0)], Gdk::DragAction::MOVE)

        tree_view.signal_connect("drag-data-get") do |widget, _drag_context, data, _info, _time|
          iter = widget.selection.selected
          next if iter.nil?

          @drag_key = key
          spell_name = iter[0].strip # Get the full string value (ID + Name)

          data.set(Gdk::Selection::TYPE_STRING, spell_name.to_s)
        end

        tree_view.signal_connect("drag-data-received") do |_widget, drag_context, _x, _y, data, _info, _time|
          dropped_spell = data.text.strip # Ensure there are no extra spaces

          next if dropped_spell.nil? || dropped_spell.empty?

          # Ensure the correct key is being used
          src_key = key == :not_to_cast ? "cast_list" : "not_to_cast"
          dst_key = key == :not_to_cast ? "not_to_cast" : "cast_list"

          # Get the actual stores for source and destination
          src_store = self["#{src_key}_store"]
          dst_store = self["#{dst_key}_store"]

          if @drag_key.to_s == dst_key.to_s
            dst_iter = dst_store.append
            dst_iter.set_value(0, dropped_spell)
          else
            # Remove the dropped spell from source store
            found = false
            src_store.each do |_model, _path, iter|
              spell_id_name = iter[0].strip # Get the full ID + Name

              if spell_id_name.eql?(dropped_spell)
                src_store.remove(iter)
                found = true
                break
              end
            end

            # Add the dropped spell to destination store
            if found
              dst_iter = dst_store.append
              dst_iter.set_value(0, dropped_spell)
            end
          end

          # Confirm drag is done
          drag_context.finish(:success => true, :delete => false, :time => Gdk::CURRENT_TIME)

          # Clear selection after the drag event
          self[src_key].selection.unselect_all
          self[dst_key].selection.unselect_all

          # Sort both source and destination stores
          src_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
          dst_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
        end

        # Handle double-click to move item
        tree_view.signal_connect("row-activated") do |widget, path, column|
          model = widget.model
          iter = model.get_iter(path)
          next if iter.nil?

          spell_name = iter[0].strip
          move_spell_between_lists(spell_name, key)

          widget.selection.unselect_all
        end
      end

      def move_spell_between_lists(spell_name, key)
        # Determine source and destination lists
        src_key = key == :not_to_cast ? "not_to_cast_store" : "cast_list_store"
        dst_key = key == :not_to_cast ? "cast_list_store" : "not_to_cast_store"

        src_store = self[src_key]
        dst_store = self[dst_key]

        # Remove from source store
        found = false
        src_store.each do |_model, _path, iter|
          if iter[0].strip == spell_name
            src_store.remove(iter)
            found = true
            break
          end
        end

        # Add to destination store
        if found
          dst_iter = dst_store.append
          dst_iter.set_value(0, spell_name)
        end

        # Sort after event
        src_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
        dst_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
      end

      def self.ewaggle_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="cast_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="dont_cast_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkAdjustment" id="minimum_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="not_to_cast_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="reserve_adjustment"><property name="upper">1000</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkAdjustment" id="start_casting_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="stop_casting_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkWindow" id="main"><property name="width-request">665</property><property name="height-request">775</property><property name="can-focus">False</property><property name="title" translatable="yes">Ewaggle Setup</property><property name="default-width">300</property><property name="default-height">500</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=2 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkScrolledWindow"><property name="height-request">250</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="cast_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">cast_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">250</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="not_to_cast"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">not_to_cast_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Spells Not to Cast</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Spells to cast</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">280</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">15</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Start Casting Below:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Stop Casting at:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="start_at"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">start_casting_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="stop_at"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">stop_casting_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Stackable Spells</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkFrame"><property name="width-request">220</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=8 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkCheckButton" id="use_multicast"><property name="label" translatable="yes">Multicast</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_wracking"><property name="label" translatable="yes">Sign of Wracking</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="wander_to_wrack"><property name="label" translatable="yes">Wander to Wrack</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_power"><property name="label" translatable="yes">Sigil of Power</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_concentration"><property name="label" translatable="yes">Sigil of Concentration</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="use_mana"><property name="label" translatable="yes">Symbol of Mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="skip_short_spells"><property name="label" translatable="yes">Skip Short Spells on Others</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="bail_no_mana"><property name="label" translatable="yes">Bail on No More Resources</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Options</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">2</property><property name="height">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-left">38</property><property name="margin-start">38</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Minimum Time:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="refreshable_min"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-left">15</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="text" translatable="yes">0</property><property name="adjustment">minimum_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Non-Stackable Spells</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-left">29</property><property name="margin-start">29</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Retribution Spell:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Reserve Mana:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="reserve_mana"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-left">15</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="text" translatable="yes">0</property><property name="adjustment">reserve_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="retribution_spell"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-left">15</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="width-chars">19</property><property name="placeholder-text" translatable="yes">Spell Number Only</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window --&gt;</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end
    end
  end
end

# Profile loading/saving
module Ewaggle
  @@data ||= nil

  def self.data
    @@data
  end

  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: (\d+\.\d+\.\d+)/i, 1]
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults()
    default_no_cast = []
    default_cast = []

    cast_list = [
      101, 102, 103, 107, 115, 120,
      202, 211, 215, 219,
      303, 307, 310, 313, 314, 319, 320,
      401, 406, 414, 425, 430,
      503, 507, 508, 509, 513, 520, 535,
      601, 602, 604, 605, 606, 612, 613, 617, 618, 620, 625, 640,
      704, 712, 716,
      905, 911, 913, 920,
      1003, 1006, 1007, 1010, 1019,
      1109, 1119, 1125, 1130,
      1202, 1204, 1208, 1214, 1215, 1220,
      1601, 1603, 1606, 1610, 1611, 1612, 1616
    ]

    cast_list.delete_if { |spell| !(Spell[spell].known? && Spell[spell].time_per > 0) }

    gtk_spells = []
    Spell.list.each { |spell| gtk_spells.push(spell) if (spell.known? && spell.time_per > 0 && spell.num.to_s =~ /(?:[1-4][0-9]|50|0[1-9])$/) }
    gtk_spells.sort_by!(&:num)

    gtk_spells.each do |spell|
      if cast_list.include?(spell.num)
        default_cast << "#{spell.num}  #{spell.name}"
      else
        default_no_cast << "#{spell.num}  #{spell.name}"
      end
    end

    # set up cast_list for the new format
    new_cast_list = []
    CharSettings['cast_list'].each do |spell|
      new_cast_list << "#{spell}  #{Spell[spell].name}"
    end

    default_cast_list = new_cast_list.length.positive? ? new_cast_list : default_cast

    default_hash = {
      start_at          => CharSettings['start_at'] || 180,
      stop_at           => [CharSettings['stop_at'] || 180, 250].min,
      refreshable_min   => CharSettings['unstackable_min'] || 15,
      use_multicast     => CharSettings['use_multicast'] || true,
      use_wracking      => CharSettings['use_wracking'] || false,
      wander_to_wrack   => CharSettings['wander_to_wrack'] || false,
      use_power         => CharSettings['use_power'] || false,
      use_mana          => CharSettings['use_mana'] || false,
      use_concentration => CharSettings['use_concentration'] || false,
      skip_jerks        => CharSettings['skip_jerks'] || false,
      skip_short_spells => CharSettings['skip_short_spells'] || false,
      bail_no_mana      => CharSettings['bail_no_mana'] || false,
      reserve_mana      => CharSettings['reserve_mana'] || 0,
      retribution_spell => CharSettings['retribution_spell'] || "",
      cast_list         => default_cast_list,
      not_to_cast       => default_no_cast
    }
    
    return default_hash
  end

  def self.load_profile
    filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ewaggle.yaml')

    if File.exist?(filename)
      settings_hash = YAML.load_file(filename)
    else
      settings_hash = Ewaggle.load_defaults
    end

    settings_hash
  end

  def self.save_profile
    filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ewaggle.yaml')
    File.write(filename, Ewaggle.data.settings.to_yaml)
    respond
    Lich::Messaging.msg('plain', " Settings saved to file: #{filename}.")
    respond
  end

  def self.test
    echo "test"
    echo Script.current.vars[2]
  end
end

# Misc Utility methods
module Ewaggle
  def self.determine_bonus(spell)
    bonus_list = Array.new
    bonus_list.push "#{'+' if spell.bolt_as > 0}#{spell.bolt_as} bAS" unless spell.bolt_as.zero?
    bonus_list.push "#{'+' if spell.physical_as > 0}#{spell.physical_as} pAS" unless spell.physical_as.zero?
    bonus_list.push "#{'+' if spell.bolt_ds > 0}#{spell.bolt_ds} bDS" unless spell.bolt_ds.zero?
    bonus_list.push "#{'+' if spell.physical_ds > 0}#{spell.physical_ds} pDS" unless spell.physical_ds.zero?
    bonus_list.push "#{'+' if spell.elemental_cs > 0}#{spell.elemental_cs} eCS" unless spell.elemental_cs.zero?
    bonus_list.push "#{'+' if spell.spirit_cs > 0}#{spell.spirit_cs} spCS" unless spell.spirit_cs.zero?
    bonus_list.push "#{'+' if spell.sorcerer_cs > 0}#{spell.sorcerer_cs} soCS" unless spell.sorcerer_cs.zero?
    bonus_list.push "#{'+' if spell.elemental_td > 0}#{spell.elemental_td} eTD" unless spell.elemental_td.zero?
    bonus_list.push "#{'+' if spell.spirit_td > 0}#{spell.spirit_td} spTD" unless spell.spirit_td.zero?
    bonus_list.push "#{'+' if spell.sorcerer_td > 0}#{spell.sorcerer_td} soTD" unless spell.sorcerer_td.zero?
    bonus_list.push "#{'+' if spell.strength.to_i > 0}#{spell.strength} str" unless spell.strength.to_i.zero?
    bonus_list.push "#{'+' if spell.dodging.to_i > 0}#{spell.dodging} dodge" unless spell.dodging.to_i.zero?
    bonus_list.join(', ')
  end

  def self.eat_bread
    return unless Ewaggle.data.settings[:use_203] # Fixme add the option in ui
    return if Effects::Spells.time_left("Manna") > 10

    empty_hand

    Casting.cast_spell(Spell[203], Char.name)

    bread = [GameObj.right_hand, GameObj.left_hand].find do |obj|
      obj.noun =~ /^(?:flatbread|teacake|crisps|cake|waybread|biscuit|oatcake|fritter|loaf|ball|cornmeal|wheatberries|cracker|dumpling|bread|tart|dough|seeds)$/
    end

    while [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(bread.id)
      fput "gobble ##{bread.id}"
      sleep 0.2
    end

    fill_hand
  end

  def self.fix_spell(spell)
    if (spell.class == Integer) or (spell.class == String and spell =~ /^[0-9]+$/)
      spell = Spell[spell.to_i]
    end
    unless spell.class == Spell
      echo "error: missing spell information for #{spell}"
      exit
    end
    spell
  end

  def self.get_target_info(target)
    res = Lich::Util.quiet_command_xml("spell active #{target}", /currently has the following active effects|has spell sharing disabled\./)

    target_info = Hash.new
    unless res.any?(/has spell sharing disabled/)
      res.each do |line|
        # Parsing from Infomon
        if line =~ /\s+([A-z0-9\s\'\(\)\-]+) \.* (([0-9]+)\:([0-9]+)\:([0-9]+)|Indefinite)$/
          spell_name = $1
          if $2 == 'Indefinite'
            spell_time = 599.0
          else
            spell_time = ($3.to_i * 60) + $4.to_i + ($5.to_i / 60.0)
          end
          if spell_name == 'Raise Dead Recovery'
            # fixme
            spell_name = 'Raise Dead Cooldown'
          elsif spell_name =~ /Mage Armor \- /
            spell_name = 'Mage Armor'
          elsif spell_name =~ /Cloak of Shadows \- /
            spell_name = 'Cloak of Shadows'
          end
          if (spell = Spell.list.find { |s| s.name == spell_name.strip() or s.num.to_s == spell_name.strip() })
            target_info[spell.num.to_s] = spell_time
          else
            echo "no spell matches #{spell_name}" if $infomon_debug
          end
        end
      end
      target_info
    else
      fput "whisper ooc #{target} Your SPELL PRIVACY settings are disabled, please enable them to allow for more efficient spell ups. Thank you."
      nil
    end
  end

  def self.help
    script_name = "#{$clean_lich_char}#{Script.current.name}"

    help_item = {
      "help"                       => "show this message",
      "setup"                      => "show setup window",
      "list"                       => "show current settings",
      "info"                       => "show what will be cast and how much it will cost",
      "info [name1] [name2]"       => "shows info for each character",
      "separator1"                 => "",
      "add [spell#]"               => "add one or more spells to the cast list (comma separated)",
      "delete [spell#]"            => "delete one or more spells from the cast list (comma separated)",
      "separator2"                 => "",
      "start-at [minutes]"         => "start casting stackable spells when there is (start_at) or less minutes remaining",
      "stop-at [minutes]"          => "stop casting if spell duration is above (stop_at)",
      "refreshable-min [minutes]"  => "minimum time less before casing for non-stacking spells",
      "separator3"                 => "",
      "multicast [on/off]"         => "use multicast",
      "wracking [on/off]"          => "use sign of wracking when out of mana",
      "wander [on/off]"            => "wander up to 20 rooms to find an empty room to wrack, then return",
      "power [on/off]"             => "use sigil of power when out of mana",
      "concentration [on/off]"     => "use sigil of concentration when out of mana",
      "mana [on/off]"              => "use symbol of mana when out of mana",
      "skip-short-spells [on/off]" => "don't cast spells with a duration less than #{Ewaggle.data.short_spell_time} minutes on others",
      "bail [on/off]"              => "stop casting if run out of mana/resource",
      "use_203 [on/off]"           => "cast/eat mana bread if 203 is known",
      "use_515 [on/off]"           => "cast 515 if know",
      "retribution-spell [#|none]" => "spell number for chant retribution after casting cloak of shadows",
      "separator4"                 => "",
      "just_script_name"           => "spell yourself up",
      "[name1] [name2] ..."        => "spell up the given people (may include your own name or word self)",
      "separator5" => "",
      "combined1"                  => { value: "Any or all saved options can be overridden on the command line without being saved using the following syntax:", colspan: 2 },
      "combined2"                  => { value: "#{script_name} --cast-list=401,406,503 --start-at=60 --stop-at=120 --stop-before=250 --retribution-spell=717 Jim Joe Bob", colspan: 2 },
      "combined3"                  => { value: "     including --save will save command line entries to your profile.", colspan: 2 },
    }

    rows = []
    help_item.each do |key, value|
      if key =~ /separator/
        rows << :separator
      elsif key =~ /combine/
        rows << [value]
      elsif key =~ /just_script_name/
        rows << ["#{script_name}", value]
      else
        rows << ["#{script_name} #{key}", value]
      end
    end

    table = Terminal::Table.new(
      title: "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version} Help",
      rows: rows,
    )

    respond
    respond table
    respond

    exit
  end

  def self.info(target_info)
    dry_run = Hash.new
    max_spell_name = 0

    # Stackable
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      max_spell_name = [max_spell_name, spell.name.length].max
      target_info.keys.each do |name|
        next unless spell.stackable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        target_info[name][spell.num.to_s] ||= 0
        dry_run[name] ||= Hash.new
        if target_info[name][spell.num.to_s] < Ewaggle.data.settings[:start_at]
          while target_info[name][spell.num.to_s] < Ewaggle.data.settings[:stop_at]
            dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
            target_info[name][spell.num.to_s] += spell.time_per(:target => name)
          end
        end
      end
    end

    # Refreshable
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      target_info.keys.each do |name|
        next unless spell.refreshable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        target_info[name][spell.num.to_s] ||= 0
        if (target_info[name][spell.num.to_s] < Ewaggle.data.settings[:refreshable_min])
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    # Solid Block
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      target_info.keys.each do |name|
        next if spell.stackable?(:target => name) or spell.refreshable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        target_info[name][spell.num.to_s] ||= 0
        unless target_info[name][spell.num.to_s] > 0
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    for name, hash in dry_run
      if hash.empty?
        respond
        Lich::Messaging.msg('plain', " #{name.capitalize}: No spells needed.")
        respond
      else
        total_casts = 0
        total_mana  = 0

        rows = []
        rows << ["#{name.capitalize}:", "Casts", "Mana", "Duration", "Bonus"]
        rows << :separator

        for spell, casts in hash
          spell = Spell[spell]
          total_casts += casts
          total_mana += casts * spell.mana_cost

          spell_duration = (spell.time_per(target: name) * casts * 60).to_i
          spell_time = "%d:%02d" % [spell_duration / 3600, (spell_duration % 3600) / 60]

          rows << ["#{spell.num} #{spell.name}", { value: casts, alignment: :right }, { value: spell.mana_cost * casts, alignment: :right }, { value: spell_time, alignment: :right }, Ewaggle.determine_bonus(spell)]
        end

        rows << :separator
        rows << [{ value: "Total:", alignment: :right }, { value: total_casts, alignment: :right }, { value: total_mana, alignment: :right }, "", ""]

        table = Terminal::Table.new :title => "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version}", :rows => rows

        respond
        respond table
        respond
      end
    end
  end

  def self.list
    rows = []
    rows << ["Parameters", "Values"]
    rows << :separator
    rows << ["start at", Ewaggle.data.settings[:start_at]]
    rows << ["stop at", Ewaggle.data.settings[:stop_at]]
    rows << ["refreshable min", Ewaggle.data.settings[:refreshable_min]]
    rows << ["multicast", Ewaggle.data.settings[:use_multicast]]
    rows << ["sign of wracking", Ewaggle.data.settings[:use_wracking]]
    rows << ["wander to wrack", Ewaggle.data.settings[:wander_to_wrack]]
    rows << ["sigil of power", Ewaggle.data.settings[:use_power]]
    rows << ["sigil of concen", Ewaggle.data.settings[:use_concentration]]
    rows << ["symbol of mana", Ewaggle.data.settings[:use_mana]]
    rows << ["skip short spells", Ewaggle.data.settings[:skip_short_spells]]
    rows << ["reserve mana", Ewaggle.data.settings[:reserve_mana]]
    rows << ["bail no resources", Ewaggle.data.settings[:bail_no_mana]]
    rows << ["use mana bread (203)", Ewaggle.data.settings[:use_203]]
    rows << ["use rapid fire (515)", Ewaggle.data.settings[:use_515]]

    retribution = Ewaggle.data.settings[:retribution_spell].to_s.empty? ? 'none' : "#{Ewaggle.data.settings[:retribution_spell]} #{Spell[Ewaggle.data.settings[:retribution_spell]]}"
    rows << ["retribution spell", retribution]
    rows << ["cast list", Ewaggle.word_wrap(Ewaggle.data.cast_list.join(', '), 30)]

    table = Terminal::Table.new(
      title: "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version} Settings",
      rows: rows,
    )

    table.align_column 0, :right

    respond
    respond table
    respond
  end

  def self.process_cli(pattern, key)
    return unless (setting = Script.current.vars.find { |var| var =~ pattern })
    Ewaggle.data.revert = true

    fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false, 'none' => false }
    value = setting.split("=").last.strip

    # Determine the value
    if fix_option.key?(value.downcase)
      value = fix_option[value.downcase] # Convert to boolean
    elsif value.include?(",") && value.match?(/^\d+(,\d+)*$/)
      value.split(",").map(&:to_i) # Convert to an array of integers
    elsif value.match?(/^\d+$/)
      value.to_i # Convert to an integer
    end

    # Adjust a couple of them
    if key == :retribution_spell && value.is_a?(FalseClass)
      Ewaggle.data.settings[key] = ''
    elsif key == :cast_list
      Ewaggle.data.settings[key] = []
      Ewaggle.data.cast_list = []
      value.each do |spell|
        spell = Spell[spell]
        next if spell.nil?

        Ewaggle.data.settings[key] << "#{spell.num}  #{spell.name}"
        Ewaggle.data.cast_list << spell.num
      end
    elsif value == "--save"
      Ewaggle.save_profile
      Ewaggle.load(Ewaggle.load_profile())
      Ewaggle.data.revert = false
    else
      Ewaggle.data.settings[key] = value
    end

    # Remove the CLI item from vars
    Script.current.vars.map! { |str| str.gsub(/#{setting}/, '').strip }.reject!(&:empty?)
  end

  def self.process_options
    need_save = false
    fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false, 'none' => false }
    item = Script.current.vars[1]
    value = Script.current.vars[2]
    matched_key = Ewaggle.data.options.keys.find { |pattern| Script.current.vars[1].match?(pattern) }
    data_key = Ewaggle.data.options[matched_key]

    case
    when fix_option.key?(value.downcase)
      value = fix_option[value.downcase] # Convert to boolean

      if Ewaggle.data.settings[data_key] == value
        respond
        Lich::Messaging.msg('plain', " #{data_key} is already set to #{value}")
        respond
      else
        Ewaggle.data.settings[data_key] = value
        respond
        Lich::Messaging.msg('plain', " #{data_key} has been set to #{value}")
        need_save = true
      end
    when value.match?(/^\d+$/) && data_key != :cast_list
      if Ewaggle.data.settings[data_key] =~ /#{value}/
        respond
        Lich::Messaging.msg('plain', " #{data_key} is already set to #{value}")
        respond
      else
        Ewaggle.data.settings[data_key] = data_key == :retribution_spell ? value.to_s : value.to_i
        respond
        Lich::Messaging.msg('plain', " #{data_key} has been set to #{value}")
        need_save = true
      end
    when data_key == :retribution_spell && value.is_a?(FalseClass)
      Ewaggle.data.settings[data_key] = ''
      echo " #{item} has been removed"
    when
      if 'add'
        add_list = Script.current.vars[2..-1].map(&:to_i).uniq

        add_list.each do |spell|
          unless Spell[spell]
            respond
            echo " #{spell} is not a valid spell."
            next
          end

          if Ewaggle.data.cast_list.include?(spell)
            respond
            Lich::Messaging.msg('plain', " #{spell} #{Spell[spell].name} is already in the casting list.")
          else
            Ewaggle.data.cast_list << spell
            Ewaggle.data.settings[:cast_list] << "#{Spell[spell].num}  #{Spell[spell].name}"
            respond
            Lich::Messaging.msg('plain', " #{spell} #{Spell[spell].name} has been added to the casting list")
            need_save = true
          end
        end
      elsif 'remove'
        del_list = Script.current.vars[2..-1].map(&:to_i)

        del_list.each do |spell|
          next unless Spell[spell]

          if Ewaggle.data.cast_list.include?(spell)
            Ewaggle.data.cast_list.delete(spell)
            Ewaggle.data.settings[:cast_list].reject! { |entry| entry.start_with?("#{Spell[spell].num} ") }
            respond
            Lich::Messaging.msg('plain', " #{spell} #{Spell[spell].name} has been removed from the casting list.")
            need_save = true
          else
            respond
            Lich::Messaging.msg('plain', " #{spell} #{Spell[spell].name} was NOT found in the casting list.")
          end
        end
      end
    end

    if need_save
      Ewaggle.save_profile
      Ewaggle.load(Ewaggle.load_profile())
    end
  end

  def self.target_info(target_list)
    target_info = Hash.new
    target_list.each do |name|
      if name == Char.name
        target_info[Char.name] = Hash.new
        Spell.active.each { |spell| target_info[Char.name][spell.num.to_s] = spell.timeleft }
      else
        spell_info = Ewaggle.get_target_info(name)
        target_info[name] = spell_info unless spell_info.nil?
      end
    end

    return target_info
  end

  def self.target_list(vars)
    target_list = []
    check_vars = vars[1] =~ /info/i ? vars[2] : vars[1]

    if check_vars
      Script.current.vars[1..-1].each do |bad_name|
        if (pc = GameObj.pcs.find { |gameobj_pc| gameobj_pc.noun =~ /^#{bad_name}/i })
          target_list.push(pc.noun)
        elsif Char.name =~ /^#{bad_name}/i || bad_name =~ /self/i
          target_list.push(Char.name)
        else
          unless bad_name == 'info'
            respond
            Lich::Messaging.msg('plain', " Bad Target: #{bad_name.capitalize}")
            respond
          end
        end
      end
    else
      target_list = [Char.name]
    end

    return target_list
  end

  def self.word_wrap(text, width = 60)
    text.gsub(/(.{1,#{width}})(\s+|\Z)/, "\\1\n").strip
  end
end

# Casting methods
module Ewaggle
  module Casting
    def self.cast_spell(spell, target, num_multicast = 1)
      result = nil
      loop {
        if Object.const_defined?(:Feat) && Feat.known?(:mental_acuity)
          Casting.check_stamina(spell, num_multicast)
        else
          Casting.check_mana(spell, num_multicast)
        end
        if target == Char.name
          if num_multicast > 1
            cast_result = spell.cast(num_multicast.to_s)
          else
            cast_result = spell.cast
          end
        else
          if num_multicast > 1
            cast_result = spell.cast("at #{target} #{num_multicast}")
          else
            cast_result = spell.cast("at #{target}")
          end
        end
        if cast_result =~ /^Be at peace my child, there is no need for spells of war in here\.$|Spells of War cannot be cast/
          result = :bad_spell
          break
        elsif cast_result == 'Cast at what?'
          result = :bad_target
          break
        elsif cast_result =~ /^\[Spell Hindrance for/
          nil # try again
        else
          result = :success
          break
        end
      }
      result
    end

    def self.cast_support
      if Ewaggle.data.settings[:use_concentration] && Spell[9714].affordable? && !Spell[9714].active?
        Spell[9714].cast
      end

      if Ewaggle.data.settings[:use_203] && Spell[203].affordable?
        Ewaggle.eat_bread
      end

      if Ewaggle.data.settings[:use_515] && Spell[515].affordable? && !Spell[515].active?
        Spell[515].cast
      end
    end

    def self.cast_refreshable(target, info)
      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next if spell.stackable?(:target => target)
        next unless spell.available?(:target => target)
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time
        next if Ewaggle.data.skip_targets.include?(target) || Ewaggle.data.skip_spells.include?(spell.num)
        next if (target == Char.name) && (spell.circlename == 'Bard') and spell.active?

        existing_duration = info[spell.num.to_s] ||= 0
        next if existing_duration > Ewaggle.data.settings[:refreshable_min]

        Casting.cast_support

        cast_result = Casting.cast_spell(spell, target)
        if cast_result == :bad_spell
          Ewaggle.data.skip_spells.push(spell.num)
        elsif cast_result == :bad_target
          Ewaggle.data.skip_targets.push(target)
        end
      end
    end

    def self.cast_solid(target, info)
      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next if spell.stackable?(:target => target) || spell.refreshable?(:target => target)
        next unless spell.available?(:target => target)
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time
        next if (target == Char.name) && (spell.circlename == 'Bard') && spell.active?

        existing_duration = info[spell.num.to_s] ||= 0
        next unless existing_duration.zero?

        Casting.cast_support

        cast_result = Casting.cast_spell.call(spell, target)
        if cast_result == :bad_spell
          Ewaggle.data.skip_spells.push(spell.num)
        elsif cast_result == :bad_target
          Ewaggle.data.skip_targets.push(target)
        end
      end
    end

    def self.cast_stackable(target, info)
      Ewaggle.data.cast_list = Ewaggle.data.cast_list.sort_by { |n| n == 625 ? 0 : n }

      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next unless spell.stackable?(:target => target)
        next unless spell.available?(:target => target)
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time
        next if (target == Char.name) && (spell.circlename == 'Bard') && spell.active?

        existing_duration = info[spell.num.to_s] ||= 0
        next if existing_duration > Ewaggle.data.settings[:start_at]
        max_multicast = Casting.max_multicast(spell)

        Casting.cast_support

        while info[spell.num.to_s] < Ewaggle.data.settings[:stop_at] && (!Ewaggle.data.skip_targets.include?(target) || !Ewaggle.data.skip_spells.include?(spell.num))
          # Adjust number_casts if needed to stay within stop_at
          remaining_time = Ewaggle.data.settings[:stop_at] - info[spell.num.to_s]
          min_needed_casts = (remaining_time.to_f / spell.time_per(target: target)).ceil
          number_casts = [min_needed_casts, max_multicast].min

          break unless number_casts.positive? # Prevents unnecessary casting

          number_casts = 1 unless Ewaggle.data.settings[:use_multicast] && spell.multicastable?

          cast_result = Casting.cast_spell(spell, target, number_casts)

          case cast_result
          when :bad_spell
            Ewaggle.data.skip_spells.push(spell.num)
            break
          when :bad_target
            Ewaggle.data.skip_targets.push(target)
            break
          else
            info[spell.num.to_s] += spell.time_per(target: target) * number_casts
          end
        end

        # Add the retribution spell
        if spell.num == 712 && target == Char.name && !Ewaggle.data.settings[:retribution_spell].empty?
          fput "chant retribution #{Ewaggle.data.settings[:retribution_spell]}"
        end
      end
    end

    def self.check_mana(spell, num_multicast)
      spell_cost = spell.mana_cost(:multicast => num_multicast) + Ewaggle.data.settings[:reserve_mana]
      return true if spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (mana >= spell_cost))
      return true if spell.stamina_cost.zero?
      return true unless spell.mana_cost > 0

      case
      when Ewaggle.data.settings[:use_wracking] # Wracking - COL
        Casting.check_mana_col(spell, num_multicast, spell_cost)
      when Ewaggle.data.settings[:use_power] # Sigil of Power - GOS
        Casting.check_mana_gos(spell, num_multicast, spell_cost)
      when Ewaggle.data.settings[:use_mana] # Symbol of Mana - Voln
        Casting.check_mana_voln(spell, num_multicast, spell_cost)
      else
        fput 'release' unless checkprep == 'None'
        echo 'waiting for mana...'
        if Ewaggle.data.settings[:bail_no_mana]
          echo 'out of resource, bailing out!'
          exit
        end
        wait_until { spell.affordable?(:multicast => num_multicast) && (spell.mana_cost == 0 || mana >= spell_cost) }
      end
    end

    def self.check_mana_col(spell, num_multicast, spell_cost)
      sign_of_wracking = Spell[9918]
      punishment = Spell[9012]

      until spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)
        waitrt?
        waitcastrt?
        if sign_of_wracking.affordable? && !punishment.active?
          if (invisible? || hidden? || !checkpcs || Casting.safe_to_wrack) && !Room.current.tags.include?('no-magic')
            sign_of_wracking.cast if sign_of_wracking.affordable? && !punishment.active?
          elsif Ewaggle.data.settings[:wander_to_wrack]
            Ewaggle.data.wander = []
            start_room = Room.current

            20.times {
              break if Casting.safe_to_wrack && !Room.current.tags.include?('no-magic')
              Casting.col_move
            }

            sign_of_wracking.cast if sign_of_wracking.affordable? && !punishment.active?

            Script.run('go2', "#{start_room.id} --disable-confirm", { quiet: true }) unless start_room.id == Room.current.id
          end
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana or spirit...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)) || sign_of_wracking.affordable? }
        end
      end
    end

    def self.col_move
      room = Room.current
      next_room_options = room.wayto.keys
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) && room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| !Ewaggle.data.wander.include?(r) }
      if next_room.empty?
        next_room = Ewaggle.data.wander.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      Ewaggle.data.wander.delete(next_room)
      Ewaggle.data.wander.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        move(way)
      else
        way.call
      end
    end

    def self.safe_to_wrack
      # Lets check player characters and see if we can wrack
      col_pattern = /^You (?:touch|scratch|rub|tap|point to) your (?:right|left) (?:eyebrow|nostril|earlobe|shoulder|cheek) with your (?:right|left) (?:pinky|forefinger|thumb|index finger)/
      lines = Lich::Util.issue_command("sign of recognition", col_pattern, usexml: true, silent: true, quiet: true)
      acknowledgers = lines.filter_map { |line| line[/noun=\"(.*?)\">.*?acknowledges your sign/, 1] }
      !(checkpcs - acknowledgers).count.positive?
    end

    def self.check_mana_gos(spell, num_multicast, spell_cost)
      sigil_of_power = Spell[9718]
      until spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)
        if sigil_of_power.affordable?
          sigil_of_power.cast
          sleep 0.2
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)) || sigil_of_power.affordable? }
        end
      end
    end

    def self.check_mana_voln(spell, num_multicast, spell_cost)
      until spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)
        waitrt?
        waitcastrt?
        if !Effects::Cooldowns.active?("Symbol of Mana")
          result = Spell[9813].cast
          if result =~ /^You strain to perform the symbol/
            echo("You're out of favor! Disabling symbol of mana usage.")
            Ewaggle.data.settings[:use_mana] = false
            break
          end
          sleep 0.2
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana or mana cooldown...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (mana >= spell_cost)) || !Effects::Cooldowns.active?("Symbol of Mana") }
        end
      end
    end

    def self.check_stamina(spell, num_multicast)
      unless spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (stamina >= (spell.mana_cost(:multicast => num_multicast) * 2) + Ewaggle.data.settings[:reserve_mana]))
        echo 'waiting for stamina...'
        if Ewaggle.data.settings[:bail_no_mana]
          echo 'out of resource, bailing out!'
          exit
        end
        wait_until { spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (stamina >= (spell.mana_cost(:multicast => num_multicast) * 2) + Ewaggle.data.settings[:reserve_mana])) }
      end
    end

    def self.max_multicast(spell)
      ranks = 0
      if Stats.prof == 'Wizard'
        ranks = Skills.emc
      elsif Stats.prof =~ /^Cleric$|^Ranger$|^Paladin$/
        ranks = Skills.smc
      elsif Stats.prof =~ /^Empath$|^Monk$|^Bard$/
        if [1, 2].include?(spell.circle.to_i)
          ranks = Skills.smc + (Skills.mmc / 2)
        elsif spell.circle.to_i == 11
          ranks = [Skills.mmc, Skills.smc].max + ([Skills.mmc, Skills.smc].min / 2)
        elsif spell.circle.to_i == 12
          ranks = Skills.mmc + (Skills.smc / 2)
        elsif spell.circle.to_i == 4
          ranks = Skills.emc + (Skills.mmc / 2)
        end
      elsif Stats.prof =~ /^Sorcerer$|^Warrior$|^Rogue$/
        if spell.circle.to_i == 4
          ranks = Skills.emc + (Skills.smc / 2)
        elsif spell.circle.to_i == 1
          ranks = Skills.smc + (Skills.emc / 2)
        elsif spell.circle.to_i == 7
          ranks = [Skills.emc, Skills.smc].max + ([Skills.emc, Skills.smc].min / 2)
        end
      end
      (ranks / 25) + 1
    end
  end
end

# Startup
module Ewaggle
  # Load profile if needed
  unless Ewaggle.data
    Ewaggle.load(Ewaggle.load_profile())
  end

  # Reset flag to revert if cli options
  Ewaggle.data.revert = false
  original_settings = Ewaggle.data.settings

  # Process any CLI options
  Ewaggle.data.cli_options.each { |pattern, key| Ewaggle.process_cli(pattern, key) }

  if Ewaggle.data.revert
    before_dying {
      Ewaggle.data.settings = original_settings
      Ewaggle.save_profile
      Ewaggle.load(Ewaggle.load_profile())
    }
  end

  case Script.current.vars[0]
  when Regexp.union(Ewaggle.data.options.keys)
    Ewaggle.process_options
  when /^load$/i
    Ewaggle.load(Ewaggle.load_profile())
  when /^setup$/i
    if defined?(Gtk)
      Ewaggle::Setup.new(Ewaggle.data.settings).start
      Ewaggle.load(Ewaggle.load_profile)
    else
      respond
      Lich::Messaging.msg('plain', 'GTK bindings are not installed or failed to load.')
      Lich::Messaging.msg('plain', "For command-line setup, see #{$clean_lich_char}#{Script.current.name} help")
      respond
    end
  when /^help$/i
    Ewaggle.help
  when /^list$|^show$/i
    Ewaggle.list
  when /^info/
    target_list = Ewaggle.target_list(Script.current.vars)
    target_info = Ewaggle.target_info(target_list)
    Ewaggle.info(target_info)
  when /^test/i
    Ewaggle.test
  when Script.current.vars[0] || nil
    Ewaggle.data.skip_spells = []
    Ewaggle.data.skip_targets = []

    target_list = Ewaggle.target_list(Script.current.vars)
    target_info = Ewaggle.target_info(target_list)
    target_info.each do |target, info|
      Casting.cast_stackable(target, info)
      Casting.cast_refreshable(target, info)
      Casting.cast_solid(target, info)
    end
  end
end
