=begin

   Script to heal yourself with herbs.

   Will use herbs in your herbsack, or on a bench or something.
   Works with any combination of herbs from any town.
   Can buy herbs.
   Might heal your traveler.

  ;eherbs help

            author: Elanthia-Online
   original author: Tillmen
              game: Gemstone
              tags: healing, herbs
          required: Lich > 5.0.1
           version: 1.0.0

   changelog:
      1.0.0 (2022-02-27):
        Global RENAME to ;eherbs
        Rewrote stock function to work at any herbalist
        Rewrote stock function to account for any 'type' of herb, so for example
           acantha leaf, acantha tea, Bloody Krolvin ale all count towards
           total doses of 'blood' herb.

      Previously as ;useherbs
      0.14 (2022-01-25):
        fix for handedness and herbs (mistaken stick for sticky and so on)
      0.13 (2021-12-17):
         updated for KF herbs
      0.12 (2020-10-10):
         response message for buying herbs now has commas
      0.11 (2020-10-07):
         changed fill function to go to closest herbalist instead of a single hardcoded one, update for commas
      0.10 (2017-09-30):
         add feature to fill your herbsack with herbs (;useherbs stock herbs)

=end
=begin

      0.9 (2017-03-04):
         remove 506 from the script, since it doesn't affect eating herbs anymore
      0.8 (2017-01-14):
         withdraw silvers first when using the "stock potions" command
      0.7 (2015-04-26):
         fix for working with hidden containers, like the basket in Ta'Vaalor
      0.6 (2015-03-28):
         remember to look on/under/behind a container instead of "in" if a second look is required
         fix bug with finding a herbsack given on the command line
      0.5 (2015-02-23):
         better method of finding container from herbsack setting
      0.4 (2014-12-12):
         make "stock potions" track potion use instead of measuring every time
      0.3 (2014-11-14):
         set herbsack with ;useherbs set herbsack <container>

=end

# fixme: garland of sovyn cloves
# fixme: skip more better
# fixme: buy herbs/right hand full
# fixme: use bank note

$known_herbs = [
  { :name => "acantha leaf",                     :type => "blood",              :short_name => "acantha laef", :store_doses => 10 },
  { :name => "some acantha leaf",                :type => "blood",              :short_name => "some acantha leaf", :store_doses => 10 },
  { :name => "some spicy acantha leaf",          :type => "blood",              :short_name => "spicy acantha leaf", :store_doses => 10 },
  { :name => "some paprika-sprinkled acantha leaf", :type => "blood",           :short_name => "some acantha leaf", :store_doses => 10 },
  { :name => "tincture of acantha",              :type => "blood",              },
  { :name => "tincture of yabathilium",          :type => "blood",              },
  { :name => "yabathilium fruit",                :type => "blood",              },
  { :name => "iceberry tart",                    :type => "blood",              :store_doses => 10 },
  { :name => "some acantha leaf tea",            :type => "blood",              :short_name => "acantha leaf tea" },
  { :name => "grey mushroom potion",             :type => "blood",              },
  { :name => "flagon of Olak's Ol'style ale",    :type => "blood",              :short_name => "Olak's Ol'style ale" },
  { :name => "barrel of Olak's Ol'style ale",    :type => "blood",              :short_name => "Olak's Ol'style ale" },
  { :name => "flagon of Bloody Krolvin ale",     :type => "blood",              :short_name => "Bloody Krolvin ale" },
  { :name => "barrel of Bloody Krolvin ale",     :type => "blood",              :short_name => "Bloody Krolvin ale" },
  { :name => "aloeas stem",                      :type => "major head wound",   :short_name => "aloeas stem",   :store_doses => 2 },
  { :name => "some aloeas stem",                 :type => "major head wound",   :short_name => "aloeas stem",   :store_doses => 2 },
  { :name => "some withered aloeas stem",        :type => "major head wound",   :short_name => "withered aloeas stem", :store_doses => 2 },
  { :name => "some anise-infused aloeas stem",   :type => "major head wound",   :short_name => "aloeas stem",   :store_doses => 2 },
  { :name => "tincture of aloeas",               :type => "major head wound",   },
  { :name => "tiny ram's bladder tart",          :type => "major head wound",   :short_name => "ram's bladder tart", :store_doses => 2 },
  { :name => "feverfew potion",                  :type => "major head wound",   },
  { :name => "sticky lichen tea",                :type => "major head wound",   },
  { :name => "flagon of Dark Swampwater ale",    :type => "major head wound",   :short_name => "Dark Swampwater ale" },
  { :name => "barrel of Dark Swampwater ale",    :type => "major head wound",   :short_name => "Dark Swampwater ale" },
  { :name => "rose-marrow potion",               :type => "minor head wound",   :store_doses => 4 },
  { :name => "crystalline rose-marrow elixir",   :type => "minor head wound",   :store_doses => 4 },
  { :name => "rose-marrow elixir",               :type => "minor head wound",   :store_doses => 4 },
  { :name => "tincture of rose-marrow",          :type => "minor head wound",   },
  { :name => "elk horn potion",                  :type => "minor head wound",   :store_doses => 4 },
  { :name => "some feverfew tea",                :type => "minor head wound",   :short_name => "feverfew tea" },
  { :name => "rusty red ale",                    :type => "minor head wound",   },
  { :name => "flagon of Semak's Smooth ale",     :type => "minor head wound",   :short_name => "Semak's Smooth ale" },
  { :name => "barrel of Semak's Smooth ale",     :type => "minor head wound",   :short_name => "Semak's Smooth ale" },
  { :name => "brostheras potion",                :type => "major head scar",    :store_doses => 2 },
  { :name => "brostheras elixir",                :type => "major head scar",    :store_doses => 2 },
  { :name => "crystalline brostheras elixir",    :type => "major head scar",    },
  { :name => "tincture of brostheras",           :type => "major head scar",    },
  { :name => "tiny cup of polar bear fat soup",  :type => "major head scar",    :short_name => 'polar bear fat soup', :store_doses => 2 },
  { :name => "pennyroyal potion",                :type => "major head scar",    },
  { :name => "stone soot brew",                  :type => "major head scar",    },
  { :name => "flagon of Reaper's Red ale",       :type => "major head scar",    :short_name => "Reaper's Red ale" },
  { :name => "barrel of Reaper's Red ale",       :type => "major head scar",    :short_name => "Reaper's Red ale" },
  { :name => "haphip root",                      :type => "minor head scar",    :short_name => "haphip root",   :store_doses => 4 },
  { :name => "some haphip root",                 :type => "minor head scar",    :short_name => "haphip root",   :store_doses => 4 },
  { :name => "some dirty haphip root",           :type => "minor head scar",    :short_name => "haphip root",   :store_doses => 4 },
  { :name => "some shredded strands of haphip root", :type => "minor head scar", :short_name => "haphip root", :store_doses => 4 },
  { :name => "tincture of haphip",               :type => "minor head scar",    },
  { :name => "slice of sparrowhawk pie",         :type => "minor head scar",    :store_doses => 5, :short_name => 'sparrowhawk pie' },
  { :name => "pennyroyal tea",                   :type => "minor head scar",    },
  { :name => "dull crimson ale",                 :type => "minor head scar",    },
  { :name => "flagon of Agrak's Amber ale",      :type => "minor head scar",    :short_name => "Agrak's Amber ale" },
  { :name => "barrel of Agrak's Amber ale",      :type => "minor head scar",    :short_name => "Agrak's Amber ale" },
  { :name => "pothinir grass", :type => "major organ wound", :short_name => "pothinir grass", :store_doses => 2 },
  { :name => "some pothinir grass", :type => "major organ wound", :short_name => "pothinir grass", :store_doses => 2 },
  { :name => "some pepper-spiced pothinir grass", :type => "major organ wound", :short_name => "pothinir grass", :store_doses => 2 },
  { :name => "some bright green pothinir grass", :type => "major organ wound",  :short_name => "pothinir grass", :store_doses => 2 },
  { :name => "tincture of pothinir",             :type => "major organ wound",  },
  { :name => "tiny musk ox tart",                :type => "major organ wound", :short_name => 'musk ox tart', :store_doses => 2 },
  { :name => "ginkgo nut potion",                :type => "major organ wound",  },
  { :name => "roasted ratweed tea",              :type => "major organ wound",  },
  { :name => "flagon of Aged Schooner ale",      :type => "major organ wound",  :short_name => "Aged Schooner ale" },
  { :name => "barrel of Aged Schooner ale",      :type => "major organ wound",  :short_name => "Aged Schooner ale" },
  { :name => "some basal moss",                  :type => "minor organ wound",  :short_name => "basal moss", :store_doses => 4 },
  { :name => "tincture of moss",                 :type => "minor organ wound",  },
  { :name => "sticky ball of basal moss",        :type => "minor organ wound",  :store_doses => 4 },
  { :name => "ball of basal moss",               :type => "minor organ wound",  :store_doses => 4 },
  { :name => "basal moss",                       :type => "minor organ wound",  :store_doses => 4 },
  { :name => "tincture of basal",                :type => "minor organ wound",  },
  { :name => "small egg and tundra grass tart",  :type => "minor organ wound",  :store_doses => 5, :short_name => 'tundra grass tart' },
  { :name => "some ginkgo nut tea",              :type => "minor organ wound",  :short_name => "ginkgo nut tea" },
  { :name => "chunky black ale",                 :type => "minor organ wound",  },
  { :name => "flagon of Mama Dwarf's ale",       :type => "minor organ wound",  :short_name => "Mama Dwarf's ale" },
  { :name => "barrel of Mama Dwarf's ale",       :type => "minor organ wound",  :short_name => "Mama Dwarf's ale" },
  { :name => "wingstem potion",                  :type => "major organ scar",   :store_doses => 2 },
  { :name => "wingstem elixir",                  :type => "major organ scar",   :short_name => "wingstem elixir", :store_doses => 2 },
  { :name => "tiny onyx glass bottle filled with wingstem elixir", :type => "major organ scar", :short_name => "wingstem elixir", :store_doses => 2 },
  { :name => "crystalline wingstem elixir",      :type => "major organ scar",   :store_doses => 2 },
  { :name => "tincture of wingstem",             :type => "major organ scar",   },
  { :name => "earthworm potion",                 :type => "major organ scar",   :store_doses => 2 },
  { :name => "wyrmwood root potion",             :type => "major organ scar",   },
  { :name => "dirty crevice brew",               :type => "major organ scar",   },
  { :name => "flagon of Wort's Winter ale",      :type => "major organ scar",   :short_name => "Wort's Winter ale" },
  { :name => "barrel of Wort's Winter ale",      :type => "major organ scar",   :short_name => "Wort's Winter ale" },
  { :name => "talneo potion",                    :type => "minor organ scar",   :store_doses => 4 },
  { :name => "crystalline talneo elixir",        :type => "minor organ scar",   },
  { :name => "talneo elixir",                  :type => "minor organ scar", :store_doses => 4 },
  { :name => "rounded blue glass bottle filled with talneo elixir", :type => "minor organ scar", :short_name => "talneo elixir", :store_doses => 4 },
  { :name => "tincture of talneo",               :type => "minor organ scar",   },
  { :name => "rock lizard potion",               :type => "minor organ scar",   :store_doses => 4 },
  { :name => "wyrmwood root tea",                :type => "minor organ scar",   },
  { :name => "brown weedroot ale",               :type => "minor organ scar",   },
  { :name => "flagon of Gert's Homemade ale",    :type => "minor organ scar",   :short_name => "Gert's Homemade ale", :store_doses => 3 },
  { :name => "barrel of Gert's Homemade ale",    :type => "minor organ scar",   :short_name => "Gert's Homemade ale", :store_doses => 10 },
  { :name => "bur-clover potion",                :type => "missing eye",        :store_doses => 1 },
  { :name => "crystalline bur-clover elixir",    :type => "missing eye",        :store_doses => 1 },
  { :name => "bur-clover elixir",                :type => "missing eye",        :store_doses => 1 },
  { :name => "tincture of bur-clover",           :type => "missing eye",        :store_doses => 1 },
  { :name => "starfish potion",                  :type => "missing eye",        :store_doses => 1 },
  { :name => "daggit root potion",               :type => "missing eye",        },
  { :name => "dirty rat fur potion",             :type => "missing eye",        },
  { :name => "flagon of Volcano Vision ale",     :type => "missing eye",        :short_name => "Volcano Vision ale", :store_doses => 3 },
  { :name => "barrel of Volcano Vision ale",     :type => "missing eye",        :short_name => "Volcano Vision ale", :store_doses => 10 },
  { :name => "some ephlox moss",                 :type => "major limb wound",   :short_name => "ephlox moss", :store_doses => 4 },
  { :name => "gooey ball of ephlox moss",        :type => "major limb wound",   },
  { :name => "twine-tied ball of ephlox moss",   :type => "major limb wound",   :short_name => "ephlox moss", :store_doses => 4 },
  { :name => "ball of ephlox moss",              :type => "major limb wound",   :short_name => "ephlox moss",   :store_doses => 4  },
  { :name => "ephlox moss",                      :type => "major limb wound",   :short_name => "ephlox moss",   :store_doses => 4  },
  { :name => "tincture of ephlox",               :type => "major limb wound",   },
  { :name => "some frog's bone porridge",        :type => "major limb wound",   :store_doses => 4, :short_name => "frog's bone porridge" },
  { :name => "sweetfern potion",                 :type => "major limb wound",   },
  { :name => "crushed cavegrass tea",            :type => "major limb wound",   },
  { :name => "flagon of Golden Goose ale",       :type => "major limb wound",   :short_name => "Golden Goose ale", :store_doses => 3 },
  { :name => "barrel of Golden Goose ale",       :type => "major limb wound",   :short_name => "Golden Goose ale", :store_doses => 10 },
  { :name => "some ambrominas leaf",             :type => "minor limb wound",   :short_name => "ambrominas leaf", :store_doses => 4 },
  { :name => "some sugary ambrominas leaf",      :type => "minor limb wound",   :short_name => "ambrominas leaf", :store_doses => 4 },
  { :name => "some syrup-glazed ambrominas leaf", :type => "minor limb wound", :short_name => "ambrominas leaf", :store_doses => 4 },
  { :name => "ambrominas leaf", :type => "minor limb wound", :short_name => "ambrominas leaf", :store_doses => 4 },
  { :name => "tincture of ambrominas",           :type => "minor limb wound",   },
  { :name => "Dabbings Family special tart",     :type => "minor limb wound",   :short_name => 'Family special tart', :store_doses => 4 },
  { :name => "some sweetfern tea",               :type => "minor limb wound",   :short_name => "sweetfern tea" },
  { :name => "bubbling brown ale",               :type => "minor limb wound",   },
  { :name => "flagon of Lost Dogwater ale",      :type => "minor limb wound",   :short_name => "Lost Dogwater ale" },
  { :name => "barrel of Lost Dogwater ale",      :type => "minor limb wound",   :short_name => "Lost Dogwater ale" },
  { :name => "some ripe calamia fruit",          :type => "major limb scar",    :short_name => "ripe calamia fruit" },
  { :name => "some calamia fruit",               :type => "major limb scar",    :short_name => "some calamia fruit", :store_doses => 2 },
  { :name => "calamia fruit",                    :type => "major limb scar",    :short_name => "calamia fruit", :store_doses => 2 },
  { :name => "tincture of calamia",              :type => "major limb scar",    },
  { :name => "slice of pickled walrus blubber",  :type => "major limb scar",    :store_doses => 2, :short_name => 'pickled walrus blubber' },
  { :name => "manroot potion",                   :type => "major limb scar",    },
  { :name => "stalactite brew",                  :type => "major limb scar",    },
  { :name => "flagon of Mad Mutt Frothy ale",    :type => "major limb scar",    :short_name => "Mad Mutt Frothy ale" },
  { :name => "barrel of Mad Mutt Frothy ale",    :type => "major limb scar",    :short_name => "Mad Mutt Frothy ale" },
  { :name => "some cactacae spine",              :type => "minor limb scar",    :short_name => "cactacae spine",   :store_doses => 4 },
  { :name => "cactacae spine",                   :type => "minor limb scar",    :short_name => "cactacae spine",   :store_doses => 4 },
  { :name => "some prickly cactacae spine",      :type => "minor limb scar",    :short_name => "prickly cactacae spine" },
  { :name => "some wood-smoked pieces of cactacae spine", :type => "minor limb scar", :short_name => "cactacae spine" },
  { :name => "tincture of cactacae",             :type => "minor limb scar",    },
  { :name => "gelatinous elk fat tart",          :type => "minor limb scar",    :short_name => 'elk fat tart', :store_doses => 10 },
  { :name => "manroot tea",                      :type => "minor limb scar",    },
  { :name => "spotted toadstool ale",            :type => "minor limb scar",    },
  { :name => "flagon of Bearded Ladies' ale",    :type => "minor limb scar",    :short_name => "Bearded Ladies' ale" },
  { :name => "barrel of Bearded Ladies' ale",    :type => "minor limb scar",    :short_name => "Bearded Ladies' ale" },
  # fixme
  { :name => "some sovyn clove",                 :type => "severed limb",       :short_name => "sovyn clove",   :store_doses => 1 },
  { :name => "small sovyn clove",                :type => "severed limb",       :short_name => "small sovyn clove",   :store_doses => 1 },
  { :name => "sovyn clove",                      :type => "severed limb",       :store_doses => 1 },
  { :name => "cumin-rubbed piece of sovyn clove",         :type => "severed limb",       :short_name => "sovyn clove", :store_doses => 1 },
  { :name => "sovyn clove",         :type => "severed limb",       :short_name => "sovyn clove", :store_doses => 1 },
  { :name => "tincture of sovyn",                :type => "severed limb",       },
  { :name => "candied ptarmigan feather",        :type => "severed limb",       :short_name => 'ptarmigan feather', :store_doses => 1 },
  { :name => "angelica root potion",             :type => "severed limb",       },
  { :name => "grainy black potion",              :type => "severed limb",       },
  { :name => "flagon of Captn' Pegleg's ale",    :type => "severed limb",       :short_name => "Captn' Pegleg's ale", :store_doses => 3 },
  { :name => "barrel of Captn' Pegleg's ale",    :type => "severed limb",       :short_name => "Captn' Pegleg's ale" },
  { :name => "bolmara potion",                   :type => "major nerve wound",  :store_doses => 4 },
  { :name => "crystalline bolmara elixir",       :type => "major nerve wound",  :store_doses => 4 },
  { :name => "bolmara elixir",                   :type => "major nerve wound",  :store_doses => 4 },
  { :name => "tiny scarlet glass bottle filled with bolmara elixir", :type => "major nerve wound", :short_name => "bolmara elixir", :store_doses => 4 },
  { :name => "tincture of bolmara",              :type => "major nerve wound",  },
  { :name => "snowflake elixir",                 :type => "major nerve wound",  :store_doses => 4 },
  { :name => "red lichen potion",                :type => "major nerve wound",  },
  { :name => "glowing mold tea",                 :type => "major nerve wound",  },
  { :name => "flagon of Kenar's Dropjaw ale",    :type => "major nerve wound",  :short_name => "Kenar's Dropjaw ale" },
  { :name => "barrel of Kenar's Dropjaw ale",    :type => "major nerve wound",  :short_name => "Kenar's Dropjaw ale" },
  { :name => "wolifrew lichen",                  :type => "minor nerve wound",  :short_name => "wolifrew lichen",   :store_doses => 4 },
  { :name => "some wolifrew lichen",             :type => "minor nerve wound",  :short_name => "wolifrew lichen",   :store_doses => 4 },
  { :name => "some dry wolifrew lichen",         :type => "minor nerve wound",  :short_name => "dry wolifrew lichen", :store_doses => 4 },
  { :name => "tincture of wolifrew",             :type => "minor nerve wound",  },
  { :name => "Leaftoe's lichen tart",            :type => "minor nerve wound",  :store_doses => 4, :short_name => 'lichen tart' },
  { :name => "some red lichen tea",              :type => "minor nerve wound",  :short_name => "red lichen tea" },
  { :name => "thick foggy ale",                  :type => "minor nerve wound",  },
  { :name => "flagon of Orc's Head ale",         :type => "minor nerve wound",  :short_name => "Orc's Head ale", :store_doses => 3 },
  { :name => "barrel of Orc's Head ale",         :type => "minor nerve wound",  :short_name => "Orc's Head ale" },
  { :name => "woth flower",                      :type => "major nerve scar",   :short_name => "woth flower", :store_doses => 2 },
  { :name => "some cube-shaped pieces of woth flower", :type => "major nerve scar", :short_name => "woth flower", :store_doses => 3 },
  { :name => "some woth flower",                 :type => "major nerve scar",   :short_name => "woth flower", :store_doses => 2 },
  { :name => "some fragrant woth flower",        :type => "major nerve scar",   :short_name => "fragrant woth flower", :store_doses => 2 },
  { :name => "tincture of woth",                 :type => "major nerve scar",   },
  { :name => "tiny flower-shaped tart",          :type => "major nerve scar",   :store_doses => 2, :short_name => 'flower-shaped tart' },
  { :name => "valerian root potion",             :type => "major nerve scar",   },
  { :name => "stalagmite brew",                  :type => "major nerve scar",   },
  { :name => "flagon of Dacra's Dream ale",      :type => "major nerve scar",   :short_name => "Dacra's Dream ale" },
  { :name => "barrel of Dacra's Dream ale",      :type => "major nerve scar",   :short_name => "Dacra's Dream ale" },
  { :name => "torban leaf",                      :type => "minor nerve scar",   :short_name => "torban leaf",   :store_doses => 3 },
  { :name => "some torban leaf",                 :type => "minor nerve scar",   :short_name => "torban leaf",   :store_doses => 3 },
  { :name => "some fresh torban leaf",           :type => "minor nerve scar",   :short_name => "fresh torban leaf", :store_doses => 3 },
  { :name => "turmeric-stained torban leaf",     :type => "minor nerve scar",   :store_doses => 4 },
  { :name => "tincture of torban",               :type => "minor nerve scar",   },
  { :name => "slice of Ma Leaftoe's Special",    :type => "minor nerve scar",   :store_doses => 5, :short_name => "Ma Leaftoe's Special" },
  { :name => "valerian root tea",                :type => "minor nerve scar",   },
  { :name => "dark frothing ale",                :type => "minor nerve scar",   },
  { :name => "flagon of Miner's Muddy ale",      :type => "minor nerve scar",   :short_name => "Miner's Muddy ale", :store_doses => 3 },
  { :name => "barrel of Miner's Muddy ale",      :type => "minor nerve scar",   :short_name => "Miner's Muddy ale" },
  { :name => "dimly glowing sky-blue potion",    :type => "disease",            },
  { :name => "dimly glowing sea-green potion",   :type => "poison",             },
]

# silence_me

drinkable         = /potion|tea|elixir|brew|tincture|ale|soup/
skippable         = Array.new
close_herbsack    = false
done_empty_hand   = false
preposition       = 'in'
return_to_stow    = false
@herb_container    = nil
@shopping_list    = Array.new
right_hand_save   = nil
left_hand_save    = nil
buy_missing       = CharSettings['buy_missing']
use_mending       = CharSettings['use-mending']
skip_scars        = CharSettings['skip-scars']
start_room        = Room.current
herb_shop_menu    = nil
silvers           = nil
withdraw_amount   = 8000
should_deposit    = false
used_herbs        = Array.new
@open_regex        = /^You open|^That is already open\.$|^There doesn't seem to be any way to do that\.$|^What were you referring to\?|^I could not find what you were referring to\./
@close_regex       = /^You close|^That is already closed\.$/
@put_regex         = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$/
@put_fail_regex    = /^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$||^I could not find what you were referring to\.$/
@get_regex         = /^You remove|^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^You already have that/
get_from          = nil
heal_cutthroat    = true
use_npchealer     = true

@min_stock_doses = {
  'major head scar' => 13,
  'minor head wound' => 11,
  'major nerve wound' => 11,
  'minor organ scar' => 11,
  'major organ scar' => 13,
  'missing eye' => 7,
  'blood' => 50,
  'major head wound' => 25,
  'minor head scar' => 25,
  'major organ wound' => 25,
  'minor organ wound' => 25,
  'major limb wound' => 25,
  'minor limb wound' => 25,
  'major limb scar' => 25,
  'minor limb scar' => 25,
  'severed limb' => 25,
  'minor nerve wound' => 25,
  'major nerve scar' => 25,
  'minor nerve scar' => 25
}

withdraw = proc {
  if $infomon_cutthroat
    echo "Cannot order without spewing blood everywhere."
    if heal_cutthroat && use_npchealer
      Script.run('go2', 'npchealer')
      fput 'lie'
      echo monsterbold_start + "This may take a minute! Exiting. . . " + monsterbold_end + "\n"
      Script.self.kill
    elsif heal_cutthroat && !use_npchealer
      Script.run('go2', 'town')
      sleep 1
      fput 'act gasps while trying to hold the blood back from the throat gash'
      sleep 1
      fput 'say Help me?'
      echo monsterbold_start + "While we're waiting on a healer - exiting. . ." + monsterbold_end + "\n"
      Script.self.kill
    end
    echo monsterbold_start + "Your cut throat requires attention! Exiting. . . " + monsterbold_end + "\n"
    echo "Waiting on a healer. . . "
    Script.self.kill
  end
  Script.run('go2', 'bank --disable-confirm')
  fput 'unhide' if invisible?
  if XMLData.room_title == '[Pinefar, Depository]'
    if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
      fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
    # The banker nods and says, "Alright, here ye go.  Ye understand I be takin' a little more than that from ye account in the 'Mule.  I don't works for free!"
    # The banker looks at you suspiciously and says, "Hmm, I don't think ye be havin' enough in ye account to cover that and my fee.  Ye tryin' to pull one over on me?"
    else
      if icemule_bank = Room.list.find { |room| room.location == 'Icemule Trace' and room.tags.include?('bank') }
        Script.run('go2', icemule_bank.id.to_s)
        result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
        if result =~ /debt collector/
          fput "withdraw #{withdraw_amount} silvers"
        end
      else
        echo 'waiting for banker...'
        wait_until { GameObj.npcs.any? { |npc| npc.noun == 'banker' } }
        fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
      end
    end
  else
    result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
    if result =~ /debt collector/
      fput "withdraw #{withdraw_amount} silvers"
    end
  end
  silvers += withdraw_amount
  should_deposit = true
}

deposit = proc {
  if should_deposit
    Script.run('go2', 'bank --disable-confirm')
    if XMLData.room_title == '[Pinefar, Depository]'
      if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
        fput "give banker #{Lich::Util.silver_count} silvers"
      end
    else
      fput "deposit #{Lich::Util.silver_count}"
    end
  end
}

too_wounded_to_cast = proc {
  ([Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max > 1) or ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max > 2) or (([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max > 0) and ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max > 0))
}

go_to_herbalist = proc {
  if working_herbalist = Room.current.find_nearest(Room.list.find_all { |room| room.tags.include?('herbalist') and not room.title.any? { |t| t =~ /Valina's Herbs and Tinctures|Marroux and Haert, Chirurgeons/ } })
    Script.run('go2', working_herbalist.to_s)
  else
    Script.run('go2', 'herbalist --disable-confirm')
  end
}

next_herb_type = proc {
  herb_type = nil
  unless herb_type
    herb_type = 'blood' if (percenthealth < 50) and not skippable.include?('blood')
  end
  unless herb_type
    for area in ['head', 'neck', 'torso', 'limbs', 'nerves'] - skippable
      if Wounds.send(area) > 1
        area = 'head' if area == 'neck'
        area = 'organ' if area == 'torso'
        area = 'limb' if area == 'limbs'
        area = 'nerve' if area == 'nerves'
        herb_type = "major #{area} wound"
        break
      end
    end
  end
  unless herb_type
    for area in ['head', 'neck', 'torso', 'limbs', 'nerves'] - skippable
      if Wounds.send(area) == 1
        area = 'head' if area == 'neck'
        area = 'organ' if area == 'torso'
        area = 'limb' if area == 'limbs'
        area = 'nerve' if area == 'nerves'
        herb_type = "minor #{area} wound"
        break
      end
    end
  end
  unless herb_type
    herb_type = 'severed limb' if (Scars.limbs == 3) and not skippable.include?('limbs')
  end
  unless herb_type
    herb_type = 'missing eye' if (Scars.reye == 3 or Scars.leye == 3) and not skippable.include?('torso')
  end
  unless herb_type
    for area in ['head', 'neck', 'torso', 'limbs', 'nerves'] - skippable
      if Scars.send(area) > 1
        area = 'head' if area == 'neck'
        area = 'organ' if area == 'torso'
        area = 'limb' if area == 'limbs'
        area = 'nerve' if area == 'nerves'
        herb_type = "major #{area} scar"
        break
      end
    end
  end
  unless herb_type
    for area in ['head', 'neck', 'torso', 'limbs', 'nerves'] - skippable
      if Scars.send(area) == 1 && !skip_scars
        area = 'head' if area == 'neck'
        area = 'organ' if area == 'torso'
        area = 'limb' if area == 'limbs'
        area = 'nerve' if area == 'nerves'
        herb_type = "minor #{area} scar"
        break
      end
    end
  end
  unless herb_type
    herb_type = 'blood' if (checkhealth + 7) < maxhealth and not skippable.include?('blood')
  end
  herb_type
}

stow_herb = proc {
  if return_to_stow and (Room.current.id != start_room.id)
    Script.run('go2', start_room.id.to_s)
  end
  if used_herbs.include?(GameObj.right_hand.id)
    dothistimeout "put ##{GameObj.right_hand.id} #{preposition} ##{@herb_container.id}", 10, @put_regex
    fput('stow right') if checkright
  end
  if used_herbs.include?(GameObj.left_hand.id)
    dothistimeout "put ##{GameObj.left_hand.id} #{preposition} ##{@herb_container.id}", 10, @put_regex
    fput('stow left') if checkleft
  end
}

read_menu = proc {
  if $infomon_cutthroat
    echo "Cannot order without spewing blood everywhere."
    if heal_cutthroat && use_npchealer
      Script.run('go2', 'npchealer')
      fput 'lie'
      echo monsterbold_start + "This may take a minute! Exiting. . ." + monsterbold_end + "\n"
      Script.self.kill
    elsif heal_cutthroat && !use_npchealer
      Script.run('go2', 'town')
      sleep 1
      fput 'act gasps while trying to hold the blood back from the throat gash'
      sleep 1
      fput 'say Help me?'
      echo monsterbold_start + "While we're waiting on a healer - exiting. . ." + monsterbold_end + "\n"
      Script.self.kill
    else
      echo monsterbold_start + "Your cut throat requires attention! Exiting. . ." + monsterbold_end + "\n"
      echo "Waiting on a healer. . . "
      Script.self.kill
    end
  end

  status_tags(onoff = "on")
  clear

  fput 'unhide' if hidden? or invisible?

  @menu = Hash.new

  fput 'order'

  while (line = get) and (line !~ /ORDER|BUY/)
    for item in line.scan(/<d.*?cmd="order ([0-9]+).*?>(.*?)<\/d>/)
      @menu[item[1].sub(/^a /, '')] = item[0]
    end
  end
  status_tags(onoff = "off")
  clear
  @menu
}

buy_herb = proc { |herb_type|
  unless silvers
    silvers = Lich::Util.silver_count() # replace check_silvers.call
  end
  unless herb_shop_menu
    herb_shop_menu = read_menu.call
  end
  herb_name = herb_shop_menu.keys.find { |name| $known_herbs.any? { |h| (h[:type] == herb_type) and (name =~ /#{h[:name]}/ or name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
  unless order_number = herb_shop_menu[herb_name]
    echo "error: failed to find a herb for #{herb_type} in the menu"
    exit
  end
  order_result = dothistimeout "order #{order_number}", 3, /^You will need a free hand|BUY/
  if order_result =~ /You will need a free hand/
    fput "put ##{GameObj.right_hand.id} in #{@herb_container}"
    fput "put ##{GameObj.left_hand.id} in #{@herb_container}"
  end
  buy_result = dothistimeout 'buy', 3, /Sold for [0-9,]+ silver|^But you do not have enough silver!|You're going to need a free hand/
  if buy_result =~ /Sold for ([0-9,]+) silver/
    silvers -= $1.gsub(',', '').to_i
  elsif buy_result =~ /^But you do not have enough silver!/
    withdraw.call
    go_to_herbalist.call if !(Room.current.tags.include?('herbalist'))
    redo
  elsif buy_result =~ /You're going to need a free hand/
    done_empty_hand = true
    empty_hands
  else
    silvers = Lich::Util.silver_count() # replace check_silvers.call
  end
  # potential fixme - no left hand check and no stow hands?
  if checkright
    GameObj.right_hand
  else
    nil
  end
}

bundle_it = proc {
  same_potion = same_herb = false
  # first get type in each hand (drinkable/munchable)
  got_salad = (GameObj.right_hand.noun !~ drinkable)
  got_croutons = (GameObj.left_hand.noun !~ drinkable)
  got_milk = (GameObj.right_hand.noun =~ drinkable)
  got_syrup = (GameObj.left_hand.noun =~ drinkable)
  # second get full name in each hand - if not the same, move on to prevent mixing
  # potion types inappropriately.
  unless got_milk.nil? or got_syrup.nil?
    same_potion = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip
  end

  unless got_salad.nil? or got_croutons.nil?
    same_herb = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip
  end

  if same_potion
    old_herb = GameObj.right_hand
    new_herb = GameObj.left_hand
    10.times {
      if (GameObj.right_hand.id == old_herb.id) or (GameObj.left_hand.id == new_herb.id)
        result = dothistimeout "pour ##{new_herb.id} in ##{old_herb.id}", 5, /^You carefully pour a little bit from your|^You can't pour|^I can't find that|^I could not find what you were referring to/
        if result =~ /^You can't pour any more in there without spilling it\./
          $eherbs_measure[old_herb.id] = 10 if old_herb.name =~ /barrel/
          $eherbs_measure[old_herb.id] = 7 if old_herb.name !~ /barrel/
          break
        elsif GameObj.left_hand.name == "Empty"
          break
        elsif result =~ /^You can't pour|^I can't find that|^I could not find what you were referring to/
          break
        end
      else
        break
      end
    }
  elsif same_herb
    old_herb = GameObj.right_hand
    new_herb = GameObj.left_hand
    bundle_result = dothistimeout 'bundle', 5, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$|^You can't put .* together in a bundle!/
    # SIMU does not send the full descriptions of items in right / left hands in XML
    # so we have to do this work-around.
    if bundle_result =~ /^You can't put (.*)<a exist=.*noun=.*>(.*), and (.*)<a exist=.*noun=.*>(.*) together in a bundle!/
      herb_right = $1.dup + $2.dup
      herb_left = $3.dup + $4.dup
      if herb_right != herb_left
        respond
        respond monsterbold_start + "The herbs don't match! Your old herb is #{herb_right}, and you bought #{herb_left}." + monsterbold_end
        respond
        respond "This happens when you move areas.  What you should do depends on how long you'll be in the area.  If you're moving permanently, throw the herbs in your right hand away and put the herbs in your left hand in your #{@herb_container}."
        respond "If you're only visiting temporarily, put the herbs in your right hand in another container for your return and put the herbs in your left hand in your #{@herb_container}."
        respond
        respond "When finished, run ;eherbs with your stocking options again."
        exit
      end
    end
  end
}

def find_herbsack
  unless herbsack = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
    echo "error: unable to find container \"#{UserVars.herbsack}\" in your inventory."
    exit
  end
  return herbsack
end

def get_current_stock(seek_type_list)
  @herb_container.contents.each { |obj|
    if $known_herbs.any? { |h| seek_type_list.include?(h[:type]) and h[:name] == obj.name } and $eherbs_measure[obj.id].nil?
      dothistimeout "get ##{obj.id}", 10, @get_regex
      dothistimeout "measure ##{obj.id}", 10, /^The .*? left/
      dothistimeout "put ##{obj.id} in ##{@herb_container.id}", 10, @put_regex
    end
  }
  for bippity in seek_type_list
    last_total_doses = -1
    loop {
      herb_list = @herb_container.contents.find_all { |obj| $known_herbs.find { |h| h[:name] == obj.name and h[:type] == bippity } }
      total_doses = 0; herb_list.each { |h| total_doses += $eherbs_measure[h.id].to_i }
      echo "#{bippity}: #{total_doses}"
      break unless total_doses < @min_stock_doses[bippity]
      break unless total_doses > last_total_doses

      last_total_doses = total_doses
      if herb_list.empty?
        @shopping_list.push(:category => bippity, :herb_name => "any", :herb_list => ["missing"], :needed => 2)
        break
      else
        herb_list.each { |h| @herb_name = h.name }
        details = $known_herbs.find { |h| h[:name] == @herb_name }
        if ((@min_stock_doses[bippity] - total_doses) / details[:store_doses]) >= 1
          @shopping_list.push(:category => bippity, :herb_name => @herb_name, :herb_list => herb_list, :needed => ((@min_stock_doses[bippity] - total_doses) / details[:store_doses]))
          echo "need more #{bippity}"
        end
        break
      end
    }
  end
end

stock_requested_herbs = proc {
  done_gone_to_herbalist = false
  respond
  respond "shopping list:"
  for thing in @shopping_list
    unless thing[:herb_name] == 'any'
      respond "#{thing[:herb_name].rjust(25)} (#{thing[:needed]})"
    else
      respond "any #{thing[:category]}".rjust(25) + " (#{thing[:needed]})"
    end
  end
  respond

  for thing in @shopping_list
    unless done_gone_to_herbalist
      if Lich::Util.silver_count < 1500 # check_silvers.call < 1500
        withdraw.call
      end
      go_to_herbalist.call if !(Room.current.tags.include?('herbalist'))
      done_gone_to_herbalist = true
    end
    unless done_empty_hand
      empty_hands
      done_empty_hand = true
    end
    unless thing[:herb_name] == 'any'
      while old_herb = thing[:herb_list].shift
        fput "get ##{old_herb.id}"
        30.times do
          break if GameObj.right_hand.id == old_herb.id || GameObj.left_hand.id == old_herb.id
          sleep(0.10)
        end
      end
      if checkleft and checkright
        bundle_it.call
      end
    else
      while missing_herb = thing[:herb_list].shift
        pp 'buying a new herb'
      end
    end
    unless thing[:herb_name] == 'any'
      herb_type = $known_herbs.find { |h| h[:name] == thing[:herb_name] }[:type]
    else
      herb_type = thing[:category]
    end
    thing[:needed].times {
      if buy_herb.call(herb_type)
        if checkleft and checkright
          bundle_it.call
        end
      end
    }
  end
}

if $eherbs_measure.nil?
  exec_string = "
       hide_me
       status_tags
       $eherbs_measure = Hash.new
       @doses = 0
       using = nil
       last_left_hand_id = nil
       begin
          while line = get
             if line =~ /<left exist=\"([0-9]+)\"/
                last_left_hand_id = $1
             end
             if line =~ /<prompt/
                using = nil
             elsif using
                if line =~ /^You have only about ([0-9]+) quaffs left\\./
                   $eherbs_measure[using] = $1.to_i
                elsif line =~ /^You have (?:about )?([0-9]+) (?:doses|bites) left\\./
                   $eherbs_measure[using] = $1.to_i
                elsif line =~ /^You (?:only )?have one bite left\\./
                   $eherbs_measure[using] = 1
                elsif line =~ /^You have only about one quaff left\\.|You only have one (?:dose|quaff) left\\./
                   $eherbs_measure[using] = 1
                elsif line =~ /^That was the last (?:drop|of it)\\./
                   $eherbs_measure[using] = 0
                end
             elsif line =~ /^You take a (?:drink from|bite of) your .*? exist=\"([0-9]+)\"/
                using = $1
             elsif line =~ /^You carefully pour a little bit from your .*? exist=\"([0-9]+)\" .*? into .*? exist=\"([0-9]+)\"/
                using = $1
                if $eherbs_measure[$2]
                   $eherbs_measure[$2] += 1
                end
             elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has several doses left\\./
                if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
                   $eherbs_measure[$1] = 7
                end
             elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has a few doses left\\./
                if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
                   $eherbs_measure[$1] = 4
                end
             elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has ([0-9]+) doses left\\./
                $eherbs_measure[$1] = $2.to_i
             elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has 1 dose left\\./
                $eherbs_measure[$1] = 1
             elsif line =~ /^You can't tell exactly, but .*? exist=\"(.*?)\" .*? seems to have plenty of bites left\\.$/
                if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 11) or ($eherbs_measure[$1] > 50)
                   $eherbs_measure[$1] = 50
                end
             elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has several bites left\\.$/
                if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
                   $eherbs_measure[$1] = 10
                end
             elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has a few bites left\\.$/
                if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
                   $eherbs_measure[$1] = 4
                end
             elsif line =~ /^The .*? exist=\"(.*?)\" .*? has ([0-9]+) bites left\\.$/
                $eherbs_measure[$1] = $2.to_i
             elsif line =~ /^The .*? exist=\"(.*?)\" .*? has (?:one|1) bite left\\.$/
                $eherbs_measure[$1] = 1
             elsif line =~ /^(?:Sh|H)e hands you .* <a.*?exist=\"([0-9]+)\".*?>(#{$known_herbs.collect { |h| h[:name] }.join('|')})<\\/a> and says, \"Here's your purchase\./o
                @doses = $known_herbs.find { |h| h[:name] == $2.dup }[:store_doses]
                if @doses.nil?
                   echo \"warning: no store_doses entry for \#{$2}\"
                   doses = 4
                end
             elsif line =~ /^Carefully, you combine all your <a exist=\"([0-9]+)\".*? into one bundle\\./
                if $eherbs_measure[$1.dup] and !@doses.nil?
                   $eherbs_measure[$1.dup] += @doses
                   @doses = nil
                elsif ($eherbs_measure[$1] and $eherbs_measure[$1] > 10) or ($eherbs_measure[last_left_hand_id] and $eherbs_measure[last_left_hand_id] > 10)
                   # bundle has 11 - 50 bytes
                   # overestimate so that we don't buy more than we can bundle
                   # exact count will be found if the herb is used
                   $eherbs_measure[$1] = 50
                   $eherbs_measure.delete(last_left_hand_id)
                else
                   # bundle has 2-50 bytes
                   # clear count so the bundle gets measured
                   $eherbs_measure.delete($1)
                   $eherbs_measure.delete(last_left_hand_id)
                end
             elsif line =~ /^You carefully remove one dose from your <a exist=\"([0-9]+)\"/
                if $eherbs_measure[$1]
                   $eherbs_measure[$1] -= 1
                end
                $eherbs_measure[last_left_hand_id] = 1
             end
             line
          end
       ensure
          $eherbs_measure = nil
       end
    "
  start_exec_script(exec_string, flags = { :quiet => true })
end

if script.vars[0] =~ /help/i
  respond
  respond 'To use the herbs in your herbsack (see below for setting your herbsack):'
  respond
  respond '   ;eherbs'
  respond
  respond 'To use the herbs on a bench or something:'
  respond
  respond '   ;eherbs on bench'
  respond
  respond '   ;eherbs behind altar'
  respond
  respond 'To use the herbs on a bench without picking up the edible herbs:'
  respond
  respond '   ;eherbs on bench --no-get'
  respond
  respond 'To look up what herbs heal what:'
  respond
  respond '   ;eherbs list'
  respond
  respond '   Append any combination of these to the previous example to narrow down the list: minor, major, severed, missing, head, organ, limb, nerve, eye, blood, wound, scar'
  respond
  respond "To heal your Adventurer's Guild escort (not well tested):"
  respond
  respond '   ;eherbs escort'
  respond
  respond 'Options (add these to the end of the command; these override default options):'
  respond
  respond '   --buy=<on/off>         Go to the herbalist to buy herbs if needed'
  respond '   --mending=<on/off>     Use sigil of mending before using herbs'
  respond '   --skipscars=<on/off>   Skip rank 1 scar healing'
  respond
  respond "Change default options (so you don't have to specify the option every time):"
  respond
  respond '   ;eherbs set buy <on/off>           same as above'
  respond '   ;eherbs set mending <on/off>       same as above'
  respond '   ;eherbs set skipscars <on/off>     same as above'
  respond "   ;eherbs set herbsack <container>   sets which container you use if one isn't"
  respond '                                        specified on the command line'
  respond
  exit
elsif script.vars[1] =~ /^list$/i
  known_herbs = $known_herbs.dup
  if (script.vars[0] =~ /major|severed|missing/i) and (script.vars[0] !~ /minor/i)
    known_herbs.delete_if { |herb| herb[:type] !~ /major|severed|missing/i }
  elsif (script.vars[0] =~ /minor/i) and (script.vars[0] !~ /major|severed|missing/i)
    known_herbs.delete_if { |herb| herb[:type] !~ /minor/ }
  end
  if (script.vars[0] =~ /wound/i) and (script.vars[0] !~ /scar|missing|severed/i)
    known_herbs.delete_if { |herb| herb[:type] !~ /wound/ }
  elsif (script.vars[0] =~ /scar|missing|severed/i) and (script.vars[0] !~ /wound/i)
    known_herbs.delete_if { |herb| herb[:type] !~ /scar|missing|severed/ }
  end
  if script.vars[0] =~ /head|neck|organ|limb|leg|arm|hand|nerve|eye|blood|health|poison|posion|disease/
    known_herbs.delete_if { |herb| herb[:type] =~ /head/ } unless script.vars[0] =~ /head|neck/
    known_herbs.delete_if { |herb| herb[:type] =~ /organ|eye/ } unless script.vars[0] =~ /organ|eye/
    known_herbs.delete_if { |herb| herb[:type] =~ /limb/ } unless script.vars[0] =~ /limb|leg|arm|hand/
    known_herbs.delete_if { |herb| herb[:type] =~ /nerve/ } unless script.vars[0] =~ /nerve/
    known_herbs.delete_if { |herb| herb[:type] =~ /blood/ } unless script.vars[0] =~ /blood|health/
    known_herbs.delete_if { |herb| herb[:type] =~ /poison/ } unless script.vars[0] =~ /poison|posion/
    known_herbs.delete_if { |herb| herb[:type] =~ /disease/ } unless script.vars[0] =~ /disease/
  end
  list = Hash.new
  for herb in $known_herbs
    list[herb[:type]] ||= Array.new
    list[herb[:type]].push(herb[:name])
  end
  output = "\n"
  for type, herbs in list
    output.concat monsterbold_start + "#{type}:" + monsterbold_end + " #{herbs.join(', ')}\n"
  end
  output.concat "\n"
  if defined?(_respond)
    _respond output
  else
    puts output
  end
  exit
elsif script.vars[1] == 'set'
  if script.vars[2] == 'buy'
    if script.vars[3] =~ /^(?:on|true|yes)$/
      CharSettings['buy_missing'] = true
      echo 'setting saved'
    elsif script.vars[3] =~ /^(?:off|false|no)$/
      CharSettings['buy_missing'] = false
      echo 'setting saved'
    else
      echo "error: bad setting value: #{script.vars[3]}"
    end
  elsif script.vars[2] == 'mending'
    if script.vars[3] =~ /^(?:on|true|yes)$/
      CharSettings['use-mending'] = true
      echo 'setting saved'
    elsif script.vars[3] =~ /^(?:off|false|no)$/
      CharSettings['use-mending'] = false
      echo 'setting saved'
    else
      echo "error: bad setting value: #{script.vars[3]}"
    end
  elsif script.vars[2] == 'skipscars'
    if script.vars[3] =~ /^(?:on|true|yes)$/
      CharSettings['skip-scars'] = true
      echo 'setting saved'
    elsif script.vars[3] =~ /^(?:off|false|no)$/
      CharSettings['skip-scars'] = false
      echo 'setting saved'
    else
      echo "error: bad setting value: #{script.vars[3]}"
    end
  elsif script.vars[2] == 'herbsack'
    if script.vars[3]
      name = script.vars[3..-1].join(' ')
      obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
      if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name == name }
      end
      if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
      end
      if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
      end
      if obj_list.empty?
        echo "error: failed to find a container in your inventory by the name of \"#{name}\""
      elsif obj_list.length > 1
        echo "error: multiple containers in your inventory match the name \"#{name}\""
      else
        UserVars.herbsack = name
        echo 'setting saved'
      end
    else
      echo 'error: no container name given'
    end
  else
    echo "error: unknown setting: #{script.vars[2]}"
  end
  exit
elsif script.vars[1] =~ /^buy=(on|off|true|false|yes|no)$/ # depreciated
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['buy_missing'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^mending=(on|off|true|false|yes|no)$/ # depreciated
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['use-mending'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^skipscars=(on|off|true|false|yes|no)$/ # depreciated
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['skip-scars'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1].downcase == 'fill'
  # 5-7 doses: There is a good bit left in the rose-marrow potion.
  # 3-4 doses: There is a small amount in the rose-marrow potion.
  # 1-2 doses: There is just a little left in the rose-marrow potion.
  done_empty_hands = false
  if UserVars.herbsack.nil? or UserVars.herbsack.empty?
    echo 'herbsack is not set (;eherbs set herbsack <container name>)'
    exit
  end
  if @herb_container.nil?
    @herb_container = find_herbsack
  end
  close_herbsack = false
  if @herb_container.contents.nil?
    open_result = dothistimeout "open ##{@herb_container.id}", 10, @open_regex
    if open_result =~ /^You open/
      close_herbsack = true
    else
      dothistimeout "look in ##{@herb_container.id}", 10, /In the .*? you see/
      if @herb_container.contents.nil?
        echo 'fixme 2'
        exit
      end
    end
  end

  for herb_type in ['blood', 'major head wound', 'minor head wound', 'major head scar', 'minor head scar', 'major organ wound', 'minor organ wound', 'major organ scar', 'minor organ scar', 'missing eye', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'major nerve wound', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
    unless @herb_container.contents.any? { |obj| $known_herbs.any? { |herb| (herb[:name] == obj.name) and herb[:type] == herb_type } }
      # echo "no herb for #{herb_type}"
      if checkright
        if GameObj.right_hand.type =~ /herb/
          dothistimeout "_drag ##{GameObj.right_hand.id} ##{@herb_container.id}", 5, @put_regex
        else
          empty_hands
          done_empty_hands = true
        end
      end
      if checkleft
        if GameObj.left_hand.type =~ /herb/
          dothistimeout "_drag ##{GameObj.left_hand.id} ##{@herb_container.id}", 5, @put_regex
        else
          empty_hands
          done_empty_hands = true
        end
      end
      unless silvers
        silvers = Lich::Util.silver_count() # replace check_silvers.call
      end
      unless silvers > 4000
        withdraw.call
      end
      go_to_herbalist.call if !(Room.current.tags.include?('herbalist'))
      herb_shop_menu = read_menu.call
      herb_name = herb_shop_menu.keys.find { |name| $known_herbs.any? { |h| (h[:type] == herb_type) and (name =~ /#{h[:name]}/ or name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
      unless order_number = herb_shop_menu[herb_name]
        echo "error: failed to find a herb for #{herb_type} in the menu"
        exit
      end
      2.times {
        dothistimeout "order #{order_number}", 3, /BUY/
        buy_result = dothistimeout 'buy', 3, /Sold for [0-9,]+ silver|^But you do not have enough silver!/
        if buy_result =~ /Sold for ([0-9,]+) silver/
          silvers -= $1.gsub(',', '').to_i
        elsif buy_result =~ /^But you do not have enough silver!/
          withdraw.call
          go_to_herbalist.call if !(Room.current.tags.include?('herbalist'))
          redo
        else
          silvers = Lich::Util.silver_count() # replace check_silvers.call
        end
      }
      bundle_it.call
      if checkright
        herb = GameObj.right_hand
        dothistimeout "_drag ##{herb.id} ##{@herb_container.id}", 5, @put_regex
        if herb_info = $known_herbs.find { |h| h[:name] =~ /#{herb.name}$/ }
          $count_herbs[herb.id] = herb_info[:store_doses]
        end
      end
    end
  end
  fput "close ##{@herb_container.id}" if close_herbsack
  deposit.call
  Script.run('go2', start_room.id.to_s) if Room.current.id != start_room.id
  fill_hands if done_empty_hands
  exit
elsif script.vars[1].downcase == 'escort'
  if script.vars[2]
    unless escort = GameObj.npcs.find { |npc| (npc.id == script.vars[2]) or (npc.noun == script.vars[2]) }
      echo "Failed to find an npc with id or noun #{script.vars[2]}."
      exit
    end
  else
    unless escort = GameObj.npcs.find { |npc| npc.type =~ /escort/ }
      echo "Failed to find an escort."
      exit
    end
  end
  close_herbsack = false
  if @herb_container.nil?
    @herb_container = find_herbsack
  end
  if @herb_container.contents.nil?
    open_result = dothistimeout "open ##{@herb_container.id}", 10, @open_regex
    if open_result =~ /^You open/
      close_herbsack = true
    else
      dothistimeout "look in ##{@herb_container.id}", 10, /In the .*? you see|In the .*?\:/
      if @herb_container.contents.nil?
        echo "error: failed to find herb container contents (#{@herb_container.name}, #{@herb_container.id})"
        exit
      end
    end
  end
  look_result = dothistimeout "look ##{escort.id}", 10, /^(?:She|He) appears to be in good shape\.|^(?:She|He) has|^I could not find what you were referring to\./
  if look_result.nil?
    echo "error: timeout while trying to look at escort (#{escort.name}, #{escort.id})"
  elsif look_result =~ /^I could not find what you were referring to\./
    echo "error: can't see escort"
  elsif look_result =~ /^(?:She|He) appears to be in good shape\./
    echo 'nothing to do'
  elsif look_result =~ /^(?:She|He) has/
    escort_injuries = Array.new
    if look_result =~ /severe head trauma and bleeding from the ears/
      escort_injuries.push('major head wound')
      escort_injuries.push('major head wound')
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /minor lacerations about the head and a possible mild concussion/
      escort_injuries.push('major head wound')
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /snapped bones and serious bleeding from the neck/
      escort_injuries.push('major head wound')
      escort_injuries.push('major head wound')
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /moderate bleeding from (?:his|her) neck/
      escort_injuries.push('major head wound')
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /deep gashes and serious bleeding from (?:his|her) chest/
      escort_injuries.push('major organ wound')
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /deep lacerations across (?:his|her) chest/
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /deep gashes and serious bleeding from (?:his|her) abdomen/
      escort_injuries.push('major organ wound')
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /deep lacerations across (?:his|her) abdomen/
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /deep gashes and serious bleeding from (?:his|her) back/
      escort_injuries.push('major organ wound')
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /deep lacerations across (?:his|her) back/
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a blinded right eye/
      #        escort_injuries.push('missing eye')
      escort_injuries.push('major organ wound')
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a blinded left eye/
      #        escort_injuries.push('missing eye')
      escort_injuries.push('major organ wound')
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a swollen right eye/
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a swollen left eye/
      escort_injuries.push('major organ wound')
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a completely severed right leg/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a completely severed left leg/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a completely severed right arm/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a completely severed left arm/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a completely severed right hand/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a completely severed left hand/
      escort_injuries.push('major limb wound')
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding right leg/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding left leg/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding right arm/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding left arm/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding right hand/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a fractured and bleeding left hand/
      escort_injuries.push('major limb wound')
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a case of uncontrollable convulsions/
      escort_injuries.push('major nerve wound')
      escort_injuries.push('minor nerve wound')
    end
    if look_result =~ /a case of sporadic convulsions/
      escort_injuries.push('major nerve wound')
      escort_injuries.push('minor nerve wound')
    end
    if look_result =~ /minor bruises about the head/
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /minor bruises on (?:his|her) neck/
      escort_injuries.push('minor head wound')
    end
    if look_result =~ /minor cuts and bruises on (?:his|her) chest/
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /minor cuts and bruises on (?:his|her) abdomen/
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /minor cuts and bruises on (?:his|her) back/
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a bruised right eye/
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /a bruised left eye/
      escort_injuries.push('minor organ wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) right leg/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) left leg/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) right arm/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) left arm/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) right hand/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /some minor cuts and bruises on (?:his|her) left hand/
      escort_injuries.push('minor limb wound')
    end
    if look_result =~ /a strange case of muscle twitching/
      escort_injuries.push('minor nerve wound')
    end
    echo escort_injuries.inspect
    empty_right_hand
    for herb_type in escort_injuries
      herb = nil
      if $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.right_hand.name or (h[:short_name] and h[:short_name] == GameObj.right_hand.name)) }
        herb = GameObj.right_hand
      elsif $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.left_hand.name or (h[:short_name] and h[:short_name] == GameObj.left_hand.name)) }
        herb = GameObj.left_hand
      else
        stow_herb.call
        if herb = @herb_container.contents.find { |i| $known_herbs.find { |h| (h[:name] == i.name) and h[:type] == herb_type } }
          used_herbs.push(herb.id) unless used_herbs.include?(herb.id)
          get_result = dothistimeout "get ##{herb.id}", 5, @get_regex
          if get_result.nil? or (get_result =~ /^Get what\?/)
            echo "error: timeout while trying to get herb (#{herb.name}, #{herb.id})"
            dothistimeout "close ##{@herb_container.id}", 5, @close_regex if close_herbsack
            exit
          elsif get_result =~ /^You need a free hand for that\./
            echo 'fixme 28382'
            dothistimeout "close ##{@herb_container.id}", 5, @close_regex if close_herbsack
            exit
          end
        end
      end
      if herb
        dothistimeout "give ##{escort.id}", 10, /accepts your .* hands it back to you|ignores your offer/
      end
    end
    stow_herb.call
    fill_right_hand
  end
  if close_herbsack
    dothistimeout "close ##{@herb_container.id}", 5, @close_regex
  end
  exit
elsif script.vars[1].downcase == 'stock'
  echo ";eherbs stock is temporarily disabled for a complete rewrite - use ;eherbs fill"
=begin
  close_herbsack = false
  if UserVars.herbsack.nil? or UserVars.herbsack.empty?
    echo 'herbsack is not set (;eherbs set herbsack <container name>)'
    exit
  end
  if @herb_container.nil?
    @herb_container = find_herbsack
  end
  if @herb_container.contents.nil?
    open_result = dothistimeout "open ##{@herb_container.id}", 10, @open_regex
    if open_result =~ /^You open/
      close_herbsack = true
    else
      dothistimeout "look in ##{@herb_container.id}", 10, /In the .*? you see|In the .*?\:/
      if @herb_container.contents.nil?
        echo "error: timeout while trying to look in herb container (#{@herb_container.name}, #{@herb_container.id})"
        exit
      end
    end
  end
  if script.vars[2].nil? or (script.vars[2].downcase =~ /potions|herbs/)
    # The distinction of only edible herbs for certain wounds was lost with Teras.
    # This prevented the script from stocking anywhere but a few locations.  Now,
    # the script deals in categories rather than specific names, and can stock
    # anywhere.
    @shopping_list = Array.new
    herb_type_list = ['blood', 'major head wound', 'minor head scar', 'major organ wound', 'minor organ wound', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
    potion_type_list = ['major head scar', 'minor head wound', 'major nerve wound', 'minor organ scar', 'major organ scar', 'missing eye']
    if script.vars[2].downcase == 'potions'
      seek_type_list = potion_type_list
    elsif script.vars[2].downcase == 'herbs'
      seek_type_list = herb_type_list
    else
      seek_type_list = potion_type_list + herb_type_list
    end
    done_empty_hand = false

    # take stock of current herbs in herb_container, and populate @shopping_list
    get_current_stock(seek_type_list)
    stock_requested_herbs.call unless @shopping_list.empty?

    dothistimeout "put ##{GameObj.right_hand.id} in ##{@herb_container.id}", 5, @put_regex if checkright
    dothistimeout "put ##{GameObj.left_hand.id} in ##{@herb_container.id}", 5, @put_regex if checkleft
    fill_hands if done_empty_hand
    deposit.call
    unless Room.current.id == start_room.id
      Script.run('go2', start_room.id.to_s)
    end
  end
=end
  exit
end

unless ([Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 0) or ((checkhealth + 7) < maxhealth)
  respond
  respond 'Missing herb for Hypochondriasis.'
  respond
  exit
end

#
# set up
#
if script.vars.any? { |var| var =~ /^--buy(?:-missing)?=(on|off|true|false|yes|no)$/i }
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  buy_missing = fix_option[$1]
  script.vars.delete_if { |var| var =~ /^--buy(?:-missing)?=(on|off|true|false|yes|no)$/i }
  script.vars[0] = script.vars[1..-1].join(' ')
end
if script.vars.any? { |var| var =~ /^--mending=(on|off|true|false|yes|no)$/i }
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  use_mending = fix_option[$1]
  script.vars.delete_if { |var| var =~ /^--mending=(on|off|true|false|yes|no)$/i }
  script.vars[0] = script.vars[1..-1].join(' ')
end
if script.vars.any? { |var| var =~ /^--skipscars=(on|off|true|false|yes|no)$/i }
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  skip_scars = fix_option[$1]
  script.vars.delete_if { |var| var =~ /^--skipscars=(on|off|true|false|yes|no)$/i }
  script.vars[0] = script.vars[1..-1].join(' ')
end
if script.vars.any? { |var| var =~ /^(?:--)?no-?get$/i }
  no_get = true
  script.vars.delete_if { |var| var =~ /^(?:--)?no-?get$/i }
  script.vars[0] = script.vars[1..-1].join(' ')
else
  no_get = false
end
if script.vars[1]
  return_to_stow = true
  if script.vars[1] =~ /^(in|on|behind|under)$/i
    preposition = $1.downcase
    script.vars.delete_at(1)
    script.vars[0] = script.vars[1..-1].join(' ')
  else
    preposition = nil
  end
  if script.vars[1] =~ /^\#\-?[0-9]+$/
    @herb_container = GameObj.new(script.vars[1].sub('#', ''), '', '')
  elsif script.vars[1]
    unless @herb_container = (GameObj.loot.find { |o| o.name =~ /#{script.vars[0]}/ } || GameObj.room_desc.find { |o| o.name =~ /#{script.vars[0]}/ })
      status_tags
      result = dothistimeout "look #{preposition || 'in'} #{script.vars[0]}", 5, /^<.*?>(In|On|Under|Behind) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/
      status_tags
      if result =~ /^<.*?>(In|On|Under|Behind) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/
        preposition = $1.downcase
        @herb_container = GameObj.new($2, $3, $4)
      else
        echo "error: failed to find herb container (#{script.vars[0]})"
        exit
      end
    end
  elsif UserVars.herbsack.nil? or UserVars.herbsack.empty?
    echo "error: no herbsack set or specified on the command line"
    eixt
  else
    if @herb_container.nil?
      @herb_container = find_herbsack
    end
  end
  if preposition.nil?
    for prep in ['in', 'on', 'under', 'behind']
      look_result = dothistimeout "look #{prep} ##{@herb_container.id}", 5, /(?:In|On|Under|Behind) .*? you see|There is nothing|^That is closed\.$|^What were you referring to\?|^I could not find what you were referring to\./
      if look_result =~ /^(?:In|On|Under|Behind) .*? you see/
        preposition = $1.downcase
        break
      elsif look_result =~ /^That is closed\./
        open_result = dothistimeout "open ##{@herb_container.id}", 5, @open_regex
        close_herbsack = true
        redo if open_result =~ /^You open/
      end
    end
    if preposition.nil?
      echo 'fixme'
      exit
    end
  end
  if @herb_container.contents.nil?
    open_result = dothistimeout "open ##{@herb_container.id}", 10, @open_regex
    if open_result =~ /^You open/
      close_herbsack = true
    else
      dothistimeout "look #{preposition} ##{@herb_container.id}", 10, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
      if @herb_container.contents.nil?
        echo 'fixme 293743'
        exit
      end
    end
  end
else
  if UserVars.herbsack.nil? or UserVars.herbsack.empty?
    echo 'no container was given and herbsack is not set'
    echo '  use  ;eherbs set herbsack <container name>'
    echo '  or   ;eherbs <in|on|behind|under> <container name>'
    exit
  end
  if @herb_container.nil?
    @herb_container = find_herbsack
  end
  if @herb_container.contents.nil?
    open_result = dothistimeout "open ##{@herb_container.id}", 10, @open_regex
    if open_result =~ /^You open/
      close_herbsack = true
    else
      dothistimeout "look in ##{@herb_container.id}", 10, /In the .*? you see|In the .*?\:/
      if @herb_container.contents.nil?
        echo 'fixme 38923'
        exit
      end
    end
  end
end

empty_hand

#
# use herbs
#
while herb_type = next_herb_type.call
  if $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.right_hand.name or (h[:short_name] == GameObj.right_hand.name)) }
    herb = GameObj.right_hand
  elsif $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.left_hand.name or (h[:short_name] and h[:short_name] == GameObj.left_hand.name)) }
    herb = GameObj.left_hand
  elsif [Wounds.leftArm, Wounds.rightArm].min < 3
    if return_to_stow and start_room.id != Room.current.id
      Script.run('go2', start_room.id.to_s)
      dothistimeout "look #{preposition} ##{@herb_container.id}", 4, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
    end
    if @herb_container.contents.nil?
      dothistimeout "look #{preposition} ##{@herb_container.id}", 4, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
    end
    if herb = @herb_container.contents.find { |i| $known_herbs.find { |h| (h[:name] == i.name) and h[:type] == herb_type } }
      stow_herb.call
      unless no_get and (herb.name !~ drinkable)
        get_result = dothistimeout "get ##{herb.id}#{get_from}", 5, @get_regex
        if (get_result =~ /^Get what/) and get_from.nil?
          get_from = " from ##{@herb_container.id}"
          redo
        elsif get_result.nil? or (get_result == 'Get what?') or (get_result == "Why don't you leave some for others?")
          echo 'fixme 4'
          exit
        elsif (get_result =~ /^You need a free hand for that\.|^You need a free hand to pick that up\./) and (!checkright or !checkleft)
          herb = nil
        end
      end
    end
  end
  if buy_missing and not herb
    stow_herb.call
    unless silvers
      silvers = Lich::Util.silver_count() # replaces check_silvers.call
    end
    unless silvers > 4000
      withdraw.call
    end

    go_to_herbalist.call if !(Room.current.tags.include?('herbalist'))

    buy_herb.call(herb_type) # refactored

    if $known_herbs.any? { |info| info[:name] =~ /#{GameObj.right_hand.name}/ }
      herb = GameObj.right_hand
    elsif $known_herbs.any? { |info| info[:name] =~ /#{GameObj.left_hand.name}/ }
      herb = GameObj.left_hand
    else
      echo 'fixme: 6'
      buy_missing = false
    end
  end
  if herb
    if use_mending and (mending = Spell[9713]) and !mending.active? and mending.known? and mending.affordable?
      mending.cast
    end
    used_herbs.push(herb.id) unless used_herbs.include?(herb.id)
    if herb.name =~ drinkable
      use_cmd = "drink ##{herb.id}"
    else
      use_cmd = "eat ##{herb.id}"
    end
    use_result = dothistimeout use_cmd, 5, /^You (?:manage to )?take a (?:bite|drink)/
    if use_result.nil?
      echo 'fixme 5'
      exit
    else
      sleep 0.5
      waitrt?
    end
  else
    if herb_type =~ /head/
      skippable.push 'head'
      skippable.push 'neck'
    elsif herb_type =~ /organ|missing eye/
      skippable.push 'torso'
    elsif herb_type =~ /limb/
      skippable.push 'limbs'
    elsif herb_type =~ /nerve/
      skippable.push 'nerves'
    elsif herb_type == 'blood'
      skippable.push 'blood'
    else
      skippable.push herb_type
    end
    respond "\nMissing herb for #{herb_type}.\n\n   #{$known_herbs.find_all { |h| h[:type] == herb_type }.collect { |h| h[:name] }.join(', ')}\n\n"
  end
end

#
# clean up
#
stow_herb.call
fill_hand
dothistimeout "close ##{@herb_container.id}", 5, @close_regex if close_herbsack
deposit.call
unless Room.current.id == start_room.id
  Script.run('go2', start_room.id.to_s)
end
